# 8️⃣7️⃣ Item 87 : 커스텀 직렬화 형태를 고려해보라

<br>

## 📌 목차
1. 개요
2. 기본 직렬화 형태 사용 경우
3. 기본 직렬화 형태 사용 X 경우
4. 안되는 경우 사용 시 문제 
5. StringList 합리적 직렬화 형태
6. 기본 직렬화 형태 더 문제되는 클래스 
7. 기본, 커스텀 직렬화 사용 시 주의점 1
8. 기본, 커스텀 직렬화 사용 시 주의점 2
9. 기본, 커스텀 직렬화 사용 시 주의점 3
10. 결론

<br>

## 📍 개요

종종 다음 릴리스에서 제대로 다시 구현하기로 하고 이번 릴리스에서는 그냥 동작만 하도록 만드는 경우가 있다. 

보통은 크게 문제되지 않지만 아래의 경우 문제가 될 수 있다. 

- 클래스가 Serializable 구현
- 구현 시 기본 직렬화 형태 사용

<br>

어떤 문제가 발생하는가 하면 

- 다음 릴리스 때 버리려 한 현재의 구현에 영원히 발이 묶이게 된다.
- 기본 직렬화 형태를 버릴 수 없게 된다.

<br>

이렇기 때문에 기본 직렬화 형태를 신중히 결정하고 커스텀 직렬화 형태를 고려해보라는 것이다. 

<br>

## ✅ 기본 직렬화 형태 사용 경우

그렇다면 기본 직렬화 형태는 언제 사용할 수 있는지부터 알아보자. 

<br>

바로 객체의 물리적 표현과 논리적 내용이 같다면 기본 직렬화 형태 사용해도 무방하다고 한다. 

<br>

아래 코드와 같이 사람의 성명을 간략히 표현한 클래스에 기본 직렬화 형태를 사용해도 되는 것이다. 

성명은 논리적으로 이름, 성, 중간 이름이라는 3개의 문자열로 구성된다. 

아래 인스턴스 필드들은 이 논리적 구성요소를 정확히 반영했다. 

즉 객체의 물리적 표현 == 논리적 내용이라 기본 직렬화 형태 사용해도 되는 것이다. 

```java
public class Name implements Serializable{
	private final String lastName;
	private final String firstName;
	private final String middleName;
	
	...
}
```

<br>

기본 직렬화 형태는 유연성, 성능, 정확성 측면에서 신중히 고민한 후 합당할 때만 사용해야 한다고 한다. 

<br>

## ❎ 기본 직렬화 형태 사용 X 경우

아래 클래스는 기본 직렬화 형태에 적합하지 않은 예이다. 

문자열 리스트를 표현하는 클래스이다. 

논리적으로 일련의 문자열을 표현하는데 물리적으로는 문자열들을 이중 LinkedList로 연결한 것이다. 

즉 물리젹 표현과 논리적 표현이 같지 않은 것이다. 

```java
public final class StringList implements Serializable{
	private int size = 0;
	private Entry head = null;
	
	private static class Entry implements Serializable{
		String data;
		Entry next;
		Entry previous;
	}
	
	...
}
```

<br>

## 🚨 안되는 경우 사용 시 문제

위처럼 객체의 물리적 표현과 논리적 표현의 차이가 클 때 기본 직렬화 형태를 사용하면 크게 네 가지 면에서 문제가 생긴다고 한다. 

<br>

### 1️⃣ 1. 공개 API가 현재의 내부 표현 방식에 영구히 묶인다.

앞의 예시에서는 기본 직렬화 형태를 사용하면 private 클래스인 Entry 클래스가 공개 API가 되어 버린다. 

그래서 다음 릴리스에서 내부 표현 방식을 바꾸더라도 StringList 클래스는 아래를 지원해야 한다. 

- 여전히 LinkedList로 표현된 입력도 처리할 수 있어야 한다.
- LinkedList를 더 사용하지 않더라도 관련 코드를 절대 제거할 수 없다.

<br>

### 2️⃣ 2. 너무 많은 공간을 차지할 수 있다.

앞의 예시에서는 기본 직렬화 형태를 사용하면 아래의 것들을 기록한다. 

- 각 노드의 양방향 연결 정보
- 모든 Entry

<br>

하지만 이 2개의 것들은 내부 구현에 해당해 직렬화 형태에 포함할 가치가 없다. 

그런데 포함을 해 직렬화 형태가 너무 커진다. 

따라서 디스크에 저장하거나 네트워크로 전송하는 속도가 느려지는 문제가 생긴다. 

<br>

### 3️⃣ 3. 시간이 너무 많이 걸릴 수 있다.

직렬화 로직은 객체 그래프의 위상 = 객체들 간의 참조 관계에 관한 정보가 없다. 

따라서 직렬화 도중 객체 간의 관계를 파악하려면 객체 그래프를 직접 순회해볼 수 밖에 없다. 

이렇게 되면 시간이 많이 걸린다는 문제가 생긴다. 

<br>

### 4️⃣ 4. 스택 오버플로를 일으킬 수 있다.

기본 직렬화 형태를 사용하면 객체 그래프를 재귀 순회한다. 

이 작업은 중간 정도 크기의 객체 그래프에서도 자칫 스택 오버플로를 일으킬 수 있다고 한다. 

StringList 예시에서 원소 1000~1800개 담았을 때에도 직렬화 과정에서 스택 오버플로가 발생했다. 

<br>

## ⏩ StringList 합리적 직렬화 형태

그렇다면 StringList는 기본 직렬화 형태를 사용하지 않고 합리적인 직렬화 형태가 무엇일까?

StringList의 물리적인 상세 표현은 배제한 채 논리적인 구성만 담는 것이다. 

단순히 리스트가 포함한 문자열의 개수를 적은 다음 그 뒤로 문자열들을 나열하는 것이다. 

이것이 커스텀 직렬화 형태인 것이다. 

<br>

```java
// 코드 87-3 합리적인 커스텀 직렬화 형태를 갖춘 StringList (462-463쪽)
public final class StringList implements Serializable {
    private transient int size   = 0;
    private transient Entry head = null;

    // 이제는 직렬화되지 않는다.
    private static class Entry {
        String data;
        Entry  next;
        Entry  previous;
    }

    // 지정한 문자열을 이 리스트에 추가한다.
    public final void add(String s) {  }

    /**
     * 이 {@code StringList} 인스턴스를 직렬화한다.
     *
     * @serialData 이 리스트의 크기(포함된 문자열의 개수)를 기록한 후
     * ({@code int}), 이어서 모든 원소를(각각은 {@code String})
     * 순서대로 기록한다.
     */
    private void writeObject(ObjectOutputStream s)
            throws IOException {
        s.defaultWriteObject();
        s.writeInt(size);

        // 모든 원소를 올바른 순서로 기록한다.
        for (Entry e = head; e != null; e = e.next)
            s.writeObject(e.data);
    }

    private void readObject(ObjectInputStream s)
            throws IOException, ClassNotFoundException {
        s.defaultReadObject();
        int numElements = s.readInt();

        // 모든 원소를 읽어 이 리스트에 삽입한다.
        for (int i = 0; i < numElements; i++)
            add((String) s.readObject());
    }

    // 나머지 코드는 생략
}
```

<br>

writeObject와 readObject가 직렬화 형태를 처리한다고 한다. 

writeObject를 통해 객체를 어떻게 저장할지 정의하고, readObject를 통해 저장된 데이터를 다시 객체로 복원하는 방법을 정의한다. 

StringList의 필드 모두 transient 한정자가 붙어있다. 

해당 인스턴스 필드가 기본 직렬화 형태에 포함되지 않는다는 표시다. 

<br>

StringList의 필드 모두 transient더라도 writeObject, readObject는 각각 가장 먼저 defaultWriteObject와 defaultReadObject를 호출한다. 

defaultWriteObject 메서드가 기본 직렬화를 , defaultReadObject 메서드가 기본 역직렬화를 수행한다. 

이렇게 해야 향후 릴리스에서 transient가 아닌 인스턴스 필드가 추가되더라도 상위, 하위 모두 호환된다고 한다. 

<br>

이렇게 하면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화하면 새로 추가된 필드들은 무시된다.

이렇게 하지 않으면 역직렬화 할 때 StreamCorruptedException이 발생한다.

<br>

이렇게 커스텀 직렬화 형태를 하게 되면 앞에서 나온 문제점들을 해결할 수 있다. 

성능 문제를 보면 기본 직렬화 형태보다 커스텀 직렬화 형태를 채택했을 때 원래보다 절반 정도의 공간을 차지하며 두 배 정도 빠르게 수행된다고 한다. 

또 스택 오버플로 문제에서 스택 오버플로가 전혀 발생하지 않아 실질적으로 직렬화 할 수 있는 크기 제한이 없어진다고 한다. 

<br>

## ⛔ 기본 직렬화 형태 더 문제되는 클래스

StringList보다 기본 직렬화 형태가 더 적합하지 않은 클래스들도 있다고 한다. 

StringList의 기본 직렬화 형태는 비록 유연성과 성능이 떨어져졌더라도 정확성이 있었다. 

객체를 직렬화한 후 역직렬화하면 원래 객체를 그 불변식까지 포함해 제대로 복원하기 때문에 정확하다. 

<br>

하지만 그 불변식이 세부 구현에 따라 달라지는 객체에서는 이 정확성마저 깨질 수 있다. 

이런 클래스들이 기본 직렬화 형태가 더 문제되는 클래스인 것이다. 

해시테이블이 바로 그 예시이다. 

<br>

해시테이블은 물리적으로는 키-값 엔트리들을 담은 해시 버킷을 차례로 나열한 형태다. 

어떤 엔트리를 어떤 버킷에 담을지는 키에서 구한 해시코드가 결정한다. 

그런데 해시코드 계산 방식이 구현에 따라 달라질 수 있다. 

따라서 해시테이블에 기본 직렬화를 사용하면 심각한 버그로 이어질 수 있다. 

해시테이블을 직렬화한 후 역직렬화하면 불변식이 심각하게 훼손된 객체들이 생겨날 수 있다. 

<br>

## 1️⃣ 기본, 커스텀 직렬화 사용 시 주의점 1

기본 직렬화 형태를 사용하던 커스텀 직렬화 형태를 사용하던 주의할 점 첫번째는 아래와 같다. 

<br>

해당 객체의 논리적 상태와 무관한 필드라고 확신할 때만 transient 한정자를 생략해야 한다. 

<br>

어떤 직렬화 형태를 사용하던 defaultWriteObject 메서드를 호출하면 transient로 선언하지 않은 모든 인스턴스 필드가 직렬화 된다. 

따라서 transient로 선언해도 되는 인스턴스 필드에는 모두 transient 한정자를 붙여야 한다. 

<br>

아래와 같은 필드들도 transient를 붙여야 한다. 

- 다른 필드에서 유도되는 필드 (캐시된 해시 값처럼)
- JVM을 실행할 때마다 값이 달라지는 필드

<br>

그래서 커스텀 직렬화 형태를 사용한다면 앞의 예시처럼 대부분의 인스턴스 필드를 transient로 선언해야 한다고 한다. 

<br>

plus

기본 직렬화를 사용한다면 transient 필드들은 역직렬화될 때 기본 값으로 초기화 된다. 

- 객체 참조 필드 → null
- 숫자 기본 타입 필드 → 0
- boolean 필드 → false

<br>

기본값을 그대로 사용해서는 안된다면 아래의 방법을 사용하면 된다. 

- readObject 메서드에서 defaultReadObject 메서드 호출 → 해당 필드를 원하는 값으로 복원
- 그 값을 처음 사용할 때 초기화

<br>

## 2️⃣ 기본, 커스텀 직렬화 사용 시 주의점 2

기본 직렬화 형태를 사용하던 커스텀 직렬화 형태를 사용하던 주의할 점 두번째는 아래와 같다. 

<br>

객체의 전체 상태를 읽는 메서드에 적용해야 하는 동기화 메커니즘을 직렬화에도 적용해야 한다. 

객체의 전체 상태를 읽는 메서드에는 toString(), clone() 등이 있다고 한다. 

<br>

그래서 예를 들어 모든 메서드를 synchronized로 선언해 스레드 안전하게 만든 객체가 있다고 생각해보자. 

이 객체에 기본 직렬화를 사용하려면 writeObject도 아래 코드처럼 synchronized로 선언해야 한다. 

```java
private synchronized void writeObject(ObjectOutputStream s) throws IOException{
	s.defaultWriteObject();
}
```

<br>

직렬화도 객체 상태를 읽는 작업이기 때문에, 동시에 다른 스레드가 객체를 수정하면 데이터 불일치 문제가 발생할 수 있기 때문이다. 

<br>

writeObject 메서드 안에서 동기화 하고 싶다면 클래스의 다른 부분에서 사용하는 락 순서를 똑같이 따라야 한다고 한다. 

그렇지 않으면 자원 순서 교착 상태에 빠질 수 있다고 한다. 

<br>

## 3️⃣ 기본, 커스텀 직렬화 사용 시 주의점 3

기본 직렬화 형태를 사용하던 커스텀 직렬화 형태를 사용하던 주의할 점 세번째는 아래와 같다. 

<br>

1. 직렬화 가능 클래스 모두에 직렬 버전 UID를 명시적으로 부여하자. 
2. 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우 제외하고는 직렬 버전 UID를 절대 수정하지 말자. 

<br>

직렬 버전 UID 선언은 각 클래스에 아래 코드를 추가하면 된다.

```java
private static final long serialVersionUID = <무작위로 고른 long 값>
```

<br>

이렇게 UID를 부여하면 아래와 같은 장점들이 있다. 

- 직렬 버전 UID가 일으키는 잠재적인 호환성 문제가 사라진다.
- 성능이 조금 빨라진다. (UID 명시 안하면 런타임에 UID 생성해 복잡한 연산 수행)

<br>

이 long 값을 선택하는 기준은 새로 작성하는 클래스냐 UID 없는 기존 클래스냐에 따라 다르다. 

<br>

새로 작성하는 클래스 

- 어떤 long 값 선택하든 상관 없다.
- serialver 유틸리티 사용 가능하다.
- 생각나는 아무 값 선택해도 된다.
- UID가 꼭 고유할 필요가 없다.

<br>

직렬 버전 UID가 없는 기존 클래스 

(이 기존 클래스를 구버전으로 직렬화된 인스턴스와 호환성을 유지한 채 수정하고 싶은 경우)

- 구버전에서 사용한 자동 생성된 값 그대로 사용해야 한다.
- 구버전 클래스를 serialber 유틸리티에 입력으로 주어 실행하면 위의 자동 생성된 값 얻을 수 있다.

<br>

그래서 구버전 클래스와의 호환성을 끊고 싶다면 단순히 직렬 버전 UID의 값을 바꿔주면 된다고 한다. 

이렇게 하면 구버전으로 직렬화된 인스턴스를 역직렬화할 때 InvalidClassException이 던져진다고 한다. 

그래서 달리 말해 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우 제외하고는 직렬 버전 UID를 절대 수정하지 말자는 것이다. 

<br>

## ‼ 결론

클래스를 직렬화하기로 했다면 어떤 직렬화 형태 사용할지 심사숙고하자. 

<br>

객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합하는 경우 - 자바의 기본 직렬화 형태 사용

그렇지 않은 경우 - 객체를 적절히 설명하는 커스텀 직렬화 형태 고안

<br>

직렬화 형태도 설계할 때 시간을 들여 설계해야 한다. 

직렬화 형태에 포함된 필드도 직렬화 호환성을 유지하기 위해 영원히 지원해야 한다. 

잘못된 직렬화 형태 선택하면 클래스의 복잡성, 성능에 영구히 부정적인 영향 남긴다.