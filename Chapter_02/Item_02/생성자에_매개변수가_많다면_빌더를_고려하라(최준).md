# 2️⃣ Item2: 생성자에 매개변수가 많다면 빌더를 고려하라

<br>

## 👨‍👨‍👧‍👧 생성자에 매개변수 많다면?
`선택적 매개변수가 많을 때` 정적 팩토리 메소드, 생성자 모두 적절히 대응하기 어렵다. 

이렇게 선택적 매개변수가 많은 클래스를 구현하는 방법은 3가지가 있다. 

1. 점층적 생성자 패턴
   
2. 자바빈즈 패턴
   
3. 빌더 패턴

이 3가지 방법 중에 `선택적 매개변수가 많다면 빌더 패턴을 고려`하라는 것이다. 

각 3가지 방법에 대해서 보고 왜 빌더 패턴을 고려해야 하는지 보자. 

<br>

## 1️⃣ 방법 1. 점층적 생성자 패턴
점층적 생성자 패턴은 `매개변수 개수를 다르게 해서 생성자를 여러 개 만드는 것`이다.

아래의 코드와 같이 만드는 것이다. 

```java
public class Car{
	private final String name;
	private final int km;
	private final int cc;

	public Car (String name){~}
	public Car (String name, int km){~}
	public Car (String name, int km, int cc){~}
	public Car (int km){~};
	public Car (int km, int cc){~}
	.....
}
```

이런 클래스의 인스턴스 만들려면 원하는 매개변수 모두 포함한 생성자 중에서 가장 짧은 것 호출하면 된다. 

하지만 이런 경우 `생성자에 사용자가 지정하기 싫은 매개변수까지 포함한 경우가 많은데` 이때도 그 매개변수에 값을 지정해줘야 한다. 

이 패턴에는 다음과 같은 `문제점`이 있다. 

- 매개변수 개수 많아지면 **코드 작성하고 읽기 어려워진다**.

- 코드 읽을 때 **매개변수에 입력한 각 값이 무슨 의미인지 헷갈려진다**.

- 매개변수가 **몇 개인지도 주의**해서 봐야 한다.

- 타입 같은 매개변수 연속되어 있으면 실수로 **매개변수 순서 바꿔서 전달해도 알 수 없다**.

<br>

## 2️⃣ 방법 2. 자바빈즈 패턴
자바빈즈 패턴은 `매개변수 없는 생성자로 객체 만든 후 setter 메소드를 호출해 원하는 매개변수 값을 설정`하는 방식이다.

아래의 코드와 같이 만드는 것이다. 

```java
public class Car{
	private String name = "";
	private int km = 0;
	private int cc = 0;

	public Car (){~}

	public void setName (String name){~}
	public void setKm (int km){~}
	public void setCC (int cc){~}
	.....
}
```

이 패턴은 방법 1. 점청적 생성자 패턴의 문제점들이 보이지 않는다. 

`코드가 길어졌지만 인스턴스 만들기 쉽고 더 읽기 쉬운 코드다.` 

하지만 이 패턴도 `심각한 단점`이 있다. 

1. 객체 하나 만들려면 ***메소드 여러 개 호출***해야 한다. 

2. 객체 완전히 생성되기 전까진 ***일관성 무너진 상태***다. 

<br>

### 💥 일관성 무너진 상태란?
방법 1. 점층적 생성자 패턴에서는 매개변수들이 유효한지 생성자에서만 확인하면 된다. 

하지만 자바빈즈 패턴에서는 매개변수1에 대한 setter는 호출하고 `매개변수2에 대한 setter는 호출 안한 상태`가 있을 수 있다. 

이때 매개변수1에는 올바른 값이 있지만 매개변수2에는 올바른 값이 없어 일관성이 무너진 상태가 되는 것이다. 

즉 자바빈즈 패턴은 `인스턴스 초기화가 잘 되었는지 알기 힘든 것`이다. 

이렇게 하다가 일관성이 깨진 객체 = `특정 매개변수에 값 까먹고 넣지 않은 객체`가 만들어지면 런타임에 문제 생기는 코드가 이상한 곳에서 튀어 나올 수 있어 디버깅이 어렵다. 

이런 문제 때문에 immutable class를 만들 수 없다. 

<br>

## 3️⃣ 방법 3. 빌더 패턴
`방법 1. 점층적 생성자 패턴의 안전성 + 방법 2. 자바빈즈 패턴의 가독성 = 빌더 패턴`

빌더 패턴은 클라이언트가 직접 필요한 객체를 만드는 것이 아니다. 

빌더 패턴을 어떻게 사용하는지 보자. 

1. `필수 매개변수만으로` 생성자 or 정적 팩토리 메소드 호출해 `빌더 객체 획득`

2. 빌더 객체가 제공하는 `setter 메소드로 원하는 선택 매개변수 설정`

3. `build 메소드 호출`해 필요한 `객체 획득`

이 빌더 클래스는 획득하고자 하는 클래스 안에 정적 멤버 클래스로 만들어둔다. 

아래의 코드처럼 사용하는 것이다. 

```java
public class Car{
	private final String name;
	private final int km;
	private final int cc;
	private final int year;

	//빌더 클래스 정적 멤버 클래스로 가짐
	public static class Builder{
		//필수 매개변수
		private final String name;
		private final int km;

		//선택 매개변수 - 기본 값으로 초기화
		private int cc = 0;
		private int year = 0;
		
		//필수 매개변수 가지는 생성자
		public Builder(String name, int km){~~}

		//선택 매개변수 setter
		public Builder cc(int cc){~}
		public Builder year(int year){~}

		//build 메소드
		public Car build(){
			return new Car(this);
		}
	}
	
	//builder를 받는 private 생성자
	private Car(Builder builder){~}
}
```

이렇게 하면 클래스를 불변으로 만들 수 있는 것이다. 

위의 코드의 Car 클래스는 immutable class이다. 

또 모든 매개변수들이 한 곳에 모여 있다.

<br>

## 👍 빌더 패턴 장점
빌더 패턴에 장점은 다음과 같다.

1. 명명된 선택적 매개변수 흉내내 `코드 사용하기 쉽고 읽기 쉽다.`

2. `계층적으로 설계된 클래스`와 함께 쓰기 좋다. 

3. 상당히 `유연하다.`

각 장점들이 왜, 어떻게 장점인지 보자. 

<br>

## 1️⃣ 장점 1. 명명된 선택적 매개변수를 흉내내 코드 사용하기 쉽고 읽기 쉽다.
빌더 패턴의 setter 메소드들은 `반환 타입이 빌더 자신`이다. 

이렇게 하면 아래와 같이 연쇄적으로 호출 할 수 있다. 

```java
Car sonata = new Car.Builder("YF", 200).cc(2000).year(2).build();
```

- **`명명된 선택적 매개변수란?`**

	  명명된 매개변수 + 선택적 매개변수이다. 

	  명명된 매개변수는 매개변수를 넘길 때 매개변수 이름 + 값을 넘길 수 있는 것이다. 

	  이렇게 해서 순서에 상관없이 특정 매개변수에 값을 지정할 수 있는 것이다. 

	  선택적 매개변수는 매개변수에 기본값을 설정할 수 있는 것이다. 

	  따라서 호출 시에 해당 매개변수에 값을 전달하지 않아도 되는 것이다. 

빌더 패턴은 `선택적 매개변수로 지정하는 필드에 기본 값을 설정`해 두어서 선택적 매개변수를 실현했다. 

그리고 빌더 패턴은 `setter로 명명된 매개변수를 실현`한 것이다. 

이렇게 하면 클라이언트는 코드를 작성하기 쉽고 읽기도 쉬워지는 것이다. 

<br>

## 2️⃣ 장점 2. 계층적으로 설계된 클래스와 함께 쓰기 좋다.
계층적으로 설계된 경우 각 계층마다 추가된 다른 점이 있다.

`각 계층의 클래스에 각각에 관한 빌더를 멤버로 정의`하는 것이다. 

추상 클래스는 추상 빌더를, 구체 클래스는 구체 빌더를 갖게 한다. 

`각 하위 클래스의 빌더가 정의한 build 메소드는 해당하는 구체 하위 클래스를 반환하게 선언`한다. 

하위 클래스에서 상위 클래스의 메소드가 정의한 반환 타입이 아닌 하위 타입 반환하는 것이다. 

이런 기능을 `공변 반환 타이핑`이라고 한다. 

이 기능 사용하면 형변환에 신경 쓰지 않고도 빌더 사용할 수 있다. 

이 기능이 없다면 build로 하면 상위 타입으로 나오고 하위 타입으로 사용하려면 다시 하위 타입으로 형변환 해야 한다. 

<br>

빌더를 이용하면 `생성자에서는 할 수 없는 가변인수 매개변수를 여러 개 사용`할 수 있다. 

가변인수는 `매개변수로 들어오는 값의 개수와 상관 없이 동적으로 파라미터를 받아 기능`하도록 하는 문법이다. 

생성자는 매개변수 개수가 정해져 있고 가변인수 매개변수처럼 사용하려면 방법 1처럼 생성자 여러 개 만들어야 한다. 

방법 3. 빌더 패턴은 `각 매개변수를 적절한 메소드로 나눠서 선언`하면 되는 것이다. 

또는 메소드를 여러 번 호출하도록 하고 각 호출 때 넘겨진 매개변수들을 하나의 필드 (ex: List, Set..)에 모이게 하면 되는 것이다. 

<br>

## 3️⃣ 장점 3. 상당히 유연하다.
빌더 패턴에서는 **빌더 하나로 여러 객체를 순회하면서 만들 수 있다.**

또한 빌더에 넘기는 **매개변수에 따라 다른 객체를 만들 수도 있다.** 

그리고 객체마다 부여되는 **특정 필드들은 빌더가 알아서 채우도록 할 수도 있다.** 

<br>

## 👎 빌더 패턴 단점
빌더 패턴은 장점만 있는 것이 아니다.

단점은 아래와 같다. 

1. 객체 만들려면 먼저 `빌더부터 만들어야 한다.`

2. 점층적 생성자 패턴보다 코드 장황해 `매개변수 4개 이상 되어야 이득이다.` 

빌더를 먼저 만들어야 해서 빌더 생성 비용이 크지는 않지만 성능에 민감한 경우 문제 될 수 있다. 

하지맛 단점 2번의 경우 무조건적인 단점이라고만은 할 수 없다.

왜냐하면 매개변수 4개 이상 되어야 이득이지만 `API는 시간 지날수록 매개변수 많아지는 경향이 있다.`

그래서 방법 1, 2로 시작했다가 나중에 매개변수 많아지면 방법 3으로 전환할 수 있다. 

그렇지만 이렇게 하면 이전에 만든 생성자, 정적 팩토리 메소드들이 거슬릴 것이다. 

그래서 `애초에 방법 3. 빌더 패턴으로 시작하는 것이 나을 때가 많다.`

<br>

## 👊 결론
생성자, 정적 팩토리 메소드에 `처리해야 하는 매개변수 많다면 빌더 패턴` 선택이 좋다.

매개변수에 `선택적 매개변수가 많고 같은 타입의 매개변수가 여러 개`이면 더 좋다. 

방법 3. 빌더 패턴은 방법 1. 점층적 생성자 패턴보다 `코드를 읽고 쓰기 더 편하다.` 

그리고 방법 3. 빌더 패턴은  방법 2. 자바빈즈 패턴보다 `훨씬 안전하다.` 

<br>

## 📍 references

- [일관성](https://okky.kr/questions/1259979)

- [명명된 선택적 매개변수 1](https://deukyu.tistory.com/36)

- [명명된 선택적 매개변수 2](https://velog.io/@panboard/%EB%AA%85%EB%AA%85%EB%90%9C-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98-%EC%84%A0%ED%83%9D%EC%A0%81-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98)

- [가변인수 1](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98Varargs-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%A5%BC-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C)

- [가변인수 2](https://sleepyeyes.tistory.com/29)