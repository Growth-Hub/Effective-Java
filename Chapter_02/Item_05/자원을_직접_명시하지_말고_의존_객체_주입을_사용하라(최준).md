# 5️⃣ Item 5: 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

<br>

## 📌목차
1. 자원에 의존

2. 방법 1. 정적 유틸리티 클래스로 구현

3. 방법 2. 싱글톤 클래스로 구현

4. 방법 3. 필드에 final 제거, 필드 교체 메소드 추가

5. 방법 4. 의존 객체 주입

6. 의존 객체 주입 패턴

7. 의존 객체 주입 패턴 변형

8. 의존 객체 주입 패턴 단점…?

9. 결론

<br>

## 💎 자원에 의존

많은 클래스가 하나 이상의 `자원에 의존`한다. 

이런 클래스를 `구현할 때 4가지 방법`이 있는데 ***3가지 방법은 문제점***이 있고 `마지막 방법이 좋은 방법`이다. 

이 방법들에 대해서 알아보면서 어떤 것이 좋은 방법인지 알아볼 것이다. 

이때 예시로 맞춤법 검사기 클래스를 구현하는데 사전 클래스에 의존하는 상황을 볼 것이다. 

<br>

## 1️⃣ 방법 1. 정적 유틸리티 클래스로 구현

이전에 배운 `정적 유틸리티 클래스로 구현`하는 방법이다. 

의존하는 자원을 private static final 필드로 가지고 private 생성자를 가지고 있는 것이다. 

```java
public class SpellChecker{
	private static final Lexion dictionary = ...;

	private SpellChecker() {}

	...
}
```
<br>

## 2️⃣ 방법 2. 싱글톤 클래스로 구현

역시 이전에 배운 `싱글톤 클래스로 구현하는 방법`이다. 

의존하는 자원을 private final 필드로 가지고 private 생성자를 가지고 있는 것이다 .

여기에 추가로 객체를 반환해주는 public static 변수를 가지고 있는 것이다. 

```java
public class SpellChecker{
	private final Lexion dictionary = ...;

	private SpellChecker(...) {}
	
	public static SpellChecker INSTANCE = new SpellChecker(...){};
	...
}
```
<br>

### 👎 방법 1, 방법 2 문제점

이 두 방법의 문제점은 `의존하는 자원이 하나만 있다고 생각하고 구현한 점`이다. 

두 방법 모두 의존하는 자원 dictionary 필드가 생성할 때 값이 들어오고 바뀔 수 없다. 

실전에서는 맞춤법 검사기에서 사전을 하나만 사용하지 않는다. 

언어별 사전, 특수 어휘용 사전, 테스트용 사전 등등 많이 사용한다. 

이렇게 `의존하는 자원이 바뀌지 않으면 여러 사전을 사용할 수 없다.` 

<br>

## 3️⃣ 방법 3. 필드에 final 제거, 필드 교체 메소드 추가

이런 문제점이 있기에 `클래스가 의존하는 자원을 하나가 아니라 같은 타입의 여러 종류를 사용하도록 구현`한 것이다. 

의존하는 자원인 dictionary 필드에 final 키워드가 붙어 있어 바꿀 수 없었다. 

따라서 우선 의존하는 필드에 final 키워드를 제거한다.

그리고 여러 자원 사용할 수 있어야 하니 `의존하는 필드를 바꿀 수 있는 메소드를 추가`한 것이다. 

```java
public class SpellChecker{
	//final 키워드 제거
	private Lexion dictionary = ...;

	private SpellChecker(...) {}
	
	public static SpellChecker INSTANCE = new SpellChecker(...){};

	//필드 교체 메소드 추가
	public void setDictionary(Lexion dictionary){...}
	...
}
```

<br>

- `final이란?`
    
      자바에서 불변성을 확보할 수 있게 제공하는 키워드다. 
    
      클래스나 변수에 final을 붙이면 처음 정의된 상태가 변하지 않는다는 것을 보장한다는 것이다. 
    
      final 키워드는 단 한번만 할당될 수 있는 것(변수, 메소드, 클래스)을 정의할 때 사용하는 것이다. 
    
      즉 초기 값이 저장되면 최종적인 값이 되어 프로그램 실행 도중 수정할 수 없다는 것이다.

<br>    

### 👎 방법 3 문제점

이 방식은 `어색하고 오류를 내기 쉽다.` 

누군가 실수로 필드를 변경하는 메소드를 호출할 수 있는 것이다. 

그리고 `멀티 스레드 환경에서 쓸 수 없다.` 

왜냐하면 여러 스레드가 동시에 해당 메소드를 호출할 때 `race condition`이 일어날 수 있기 때문이다. 

이렇게 의존하는 자원이 달라지고 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱클톤 방식은 적합하지 않다. 

<br>

- `race condition이란?`
    
      race condition이란 여러 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과 값이 달라질 수 있는 현상이다. 
    
      race condition의 문제점은 똑같은 코드 여러 번 돌려도 실행 결과가 항상 같아야 하는데 결과가 달라질 수 있기 때문이다. 
    
      예를 들어 값이 1000이 있는데 A 스레드는 500을 내리고 B 스레드는 300을 내린다. 
    
      생각하기로는 둘 다 실행이 되면 200이 남아야 한다. 
    
      그런데 A 스레드, B 스레드 동시에 한 것이다. 
    
      그러면 A, B 스레드 처음에는 1000이기 때문에 값을 내리면 A 스레드는 500, B 스레드는 700 남았다고 생각한다. 
    
      이런 문제가 생길 수 있다. 
    
<br>

## 4️⃣ 방법 4. 의존 객체 주입

그러면 이렇게 클래스가 여러 자원 인스턴스 지원해야 하며 클라이언트가 원하는 자원을 사용하려면 어떻게 해야 하는가?

바로 ***`의존 객체 주입 방식을 사용`*** 하면 된다. 

`인스턴스를 생성할 때 생성자에 필요한 의존하는 자원을 넘겨주는 방식이`다. 

```java
public class SpellChecker{
	private final Lexion dictionary = ...;

	public SpellChecker(Lexicon dictionary) {
		this dictionary = Objects.requireNonNull(dictionary);
	}

	...
}
```

<br>

## 📥 의존 객체 주입 패턴

의존 객체 주입 패턴은 아주 단순하다. 

`생성자에서 파라미터로 의존하는 자원을 받으면` 되기 때문이다. 

그리고 의존하는 필드가 여러 개여도 의존 관계가 더 있어도 상관없이 잘 작동한다. 

역시 생성자에 파라미터를 더 추가해 여러 의존하는 자원 받으면 되기 때문이다. 

또한 immutable class를 보장해 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있다. 

의존하는 필드는 final 키워드가 있고 이 값을 변경할 수 있는 메소드는 없다.

이런 의존 객체 주입은 `생성자, 정적 팩토리 메소드, 빌더 모두에 똑같이 사용할 수 있다.` 

그리고 의존 객체 주입이 `유연성과 테스트 용이성을 개선`해준다. 

<br>

## 🧬 의존 객체 주입 패턴 변형

의존 객체 주입 패턴의 변형 중 사용하면 좋은 변형이 있다. 

바로 생성자에 위처럼 바로 객체를 넘겨주는 것이 아닌 `자원 팩토리를 넘겨주는 방식`이다. 

`팩토리란 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체다. `

팩토리 메소드 패턴을 구현한 것이다. 

`팩토리 메소드 패턴`이 무엇인지 먼저 알아보자. 

<br>

### 🏭 팩토리 메소드 패턴이란?

객체 생성을 팩토리 클래스로 캡슐화 해서 대신 생성하게 하는 디자인 패턴이다. 

즉 new로 객체를 생성하는 것이 아니라 `객체들을 도맡아 생성하는 팩토리 클래스를 만들고` 팩토리 클래스의 `메소드에서 객체 생성을 책임지는 것`이다. 

팩토리 메소드 매턴은 객체를 만들어내는 팩토리를 만드는 패턴이다. 

팩토리 클래스는 (아래 그림에서는 Creator) 객체를 만드는 팩토리 메소드를 추상 메소드로 들고 있는다. 

이 팩토리 메소드는 생성할 객체 (Product)의 인터페이스 타입을 반환하도록 한다. 

팩토리 클래스를 구현한 각 서브 팩토리 클래스들은 해당하는 객체를 반환하게 팩토리 메소드를 재정의한다. 

![image](https://lh3.googleusercontent.com/proxy/2ZqS_cG1aQyGSv1cLpeiKNW8lar70Q63lFV2GBHl3fFx2VPaJOGxI6OVlHS00Imd6iwfeLCuCoIDEpjTZtpLDxNOJvKPhZnGv82lgR8a-s-B6s2eox9ZTUSTKXSzVKnx69OCMYSOZYh03uKPAh1Qolen5iBfhZ3y_OrEmWqGidE1-ynIMmb9nxjaSxrJSP6XBJHLYkohHwP0DmEZYp26qk3ryLwtEWyuTr_cn9w64Be7IfM-WxLnlF_q)

<br>

![image](https://eunhyejung.github.io/assets/contents/content05.PNG)

<br>

### 🔎 팩토리의 완벽한 예시 Supplier<T>

팩토리 메소드 패턴과 팩토리에 대해 알아 보았다. 

`Supplier<T>는 팩토리의 완벽한 예시`이다. 

메소드 중에 Supplier<T>를 파라미터로 받는 메소드가 있을 수 있다. 

위에서 생성자도 이런 메소드 중 하나다. 

이때 이런 메소드들은 `Supplier에 한정적 와일드카드 타입을 사용`해야 한다.

왜 이런 메소드들은 한정적 와일드카드 타입을 사용해야 하는가 하면 `팩토리 타입 매개변수를 제한해야 하기 때문`이다. 

이해가 가지 않을 것이다. 

무슨 의미인지는 아래에서 다시 보자.

우선 `한정적 와일드카드 타입`이 무엇인지 보자. 

<br>

---
### ❓ 한정적 와일드카드 타입이란?

**`제너릭이란?`**

우선 제너릭의 개념에 대해서 알아야 한다. 

제너릭은 `타입을 일반화` 하는 것을 의미한다. 

타입의 일반화는 클래스 내부에서 개별적으로 타입을 지정하는 것이 아니라 `외부에서 지정하게끔 일반화` 시키는 것이다. 

외부에서 클래스나 메소드 사용할 때 타입을 정하는 것이다. 

<br>

**`제너릭의 문제점`**

하지만 제너릭 타입에 문제점이 있다. 

모든 타입에서 공통적으로 사용되는 메소드를 만들 방법이 없다. 

이 부분은 복잡하고 긴 내용이기에 아래 references의 ‘한정적 와일드카드 타입 1’ 링크의 글을 읽어 보면 좋을 것 같다. 

<br>

**`와일드카드란?`**

제너릭의 `문제점 때문에 와일드카드라는 타입이 추가`되었다. 

와일드카드 타입은 `모든 타입을 대신할 수 있는 타입`이다. 

정해지지 않은 unknown 타입이기에 Collection<?>로 선언해 모든 타입에 대해 호출이 가능해졌다. 

<br>

**`와일드카드의 문제점`**

하지만 와일드카드 타입도 `문제점이 있다.` 

와일드카드 타입은 unknown 타입이라 `파라미터로 와일드카드 타입을 넘기는 경우 범위가 무제한이다.` 

제너릭은 자신 또는 자식 클래스만 넣을 수 있는데 와일드카드 타입은 다 넣을 수가 있다. 

<br>

**`한정적 와일드카드`**

이런 문제점을 해결하기 위해 한정적 와일드카드가 생긴 것이다. 

한정적 와일드카드를 사용하면 `특정 타입을 기준으로 상한 범위와 하한 범위를 지정해서 호출 범위를 확장 또는 제한`할 수 있다. 

한정적 와일드카드에는 `상한 경계 와일드카드`, `하한 경계 와일드카드`가 있다. 

<br>

- **상한 경계 와일드카드**

  - 상한 경계 와일드카드는 `extends를 사용해 와일드카드 타입의 최상위 타입 정의해 상한 경계 설정`하는 것이다. 

  - 상한 경계 와일드카드에는 `자신과 자식 타입`을 넣을 수 있다. 

  - `Collection<? extends Parent>` 이렇게 사용한다. 

<br>

- **하한 경계 와일드카드**

  - 하한 경계 와일드카드는 상한 경계와 반대로 `super를 사용해 와일드카드의 최하위 타입을 정의해 하한 경계를 설정`하는 것이다. 

  - 하한 경계 와일드카드에는 `자신과 부모 타입`을 넣을 수 있다. 

  - `Collection<? super Parent>` 이렇게 사용한다. 

<br>

굉장히 간단히 설명한 것으로 이해하기 어려울 수 있다. 

이해하기 어려운 경우 좋은 글인 ***아래 references의 ‘한정적 와일드카드 타입 1’ 링크***의 글을 읽어 보면 좋을 것 같다. 

---

<br>

다시 돌아와서 '메소드 중에 Supplier<T>를 파라미터로 받는 메소드들은 Supplier에 한정적 와일드카드 타입을 사용해 팩토리 타입 매개변수를 제안해야 한다'의 의미를 보자.

이렇게 Supplier에 한정적 와일드카드 타입을 사용하면 `여기에 명시한 타입의 하위 타입이라면 무엇이든 생성할 수 있는 팩토리를 넘길 수 있다. `

아래와 같이 사용하는 것이다. 

```java
public class SpellChecker{
	private final Lexion dictionary = ...;

	public SpellChecker(Supplier<? extends dictionary> dictionaryFactory) {
		...
	}

	...
}
```

이 책에서는 한정적 와일드카드 타입 중 상한 경계 와일드카드를 사용한 것이다. 

따라서 `dictionary 타입과 자식 타입 중 어떤 타입을 넣어도 생성할 수 있는 팩토리 객체를 생성자에 넘기는 것`이다. 

<br>

`의존 객체 주입의 변형`이 생성자에 바로 객체를 넘겨주는 것이 아닌 자원 팩토리를 넘겨주는 방식이라고 했다. 

이렇게 한정적 와일드카드 타입을 사용한 Supplier라는 팩토리를 생성자에 넘기는 것이다. 

팩토리를 넘겨서 자신과 하위 타입 중 어떤 것도 주입할 수 있게 한 것이다.

이렇게 해서 `의존 객체 주입의 쓸만한 변형인 것`이다. 

<br>

## 👎 의존 객체 주입 패턴 단점…?

의존성이 수천 개나 되는 큰 프로젝트에서는 `코드가 어지럽게 될 수 있다.`

하지만 스프링 같은 `의존 객체 주입 프레임워크르 사용`하면 이런 단점을 해소할 수 있다. 

이런 프레임워크들은 의존 객체를 직접 주입하도록 설계된 API를 알맞게 응용해 사용하고 있다. 

<br>

## 🚨 결론

클래스가 내부적으로 **하나 이상에 자원에 의존하고 그 자원이 클래스 동작에 영향 준다면** 싱글톤과 정적 유틸리티 클래스는 사용하지 않는 것이 좋다.

그리고 **이 자원들을 클래스가 직접 만들게 해서도 안된다.** 

대신 `필요한 (자원 or 자원 만드는 팩토리)를 (생성자 or 정적 팩토리 메소드 or 빌더)에 넘겨주자.`

<br>

## 📍 references

- [final이란? 1](https://sudo-minz.tistory.com/135)
- [final이란? 2](https://coding-factory.tistory.com/525)
- [final이란? 3]([https://blog.advenoh.pe.kr/java/자바에서-final에-대한-이해/](https://blog.advenoh.pe.kr/java/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-final%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%ED%95%B4/))
- [race condition이란? 1](https://charles098.tistory.com/88)
- [race condition이란? 2](https://easyitwanner.tistory.com/135)
- [팩토리 메서드 패턴이란? 1](https://jake-seo-dev.tistory.com/366)
- [팩토리 메서드 패턴이란? 2]([https://inpa.tistory.com/entry/GOF-💠-팩토리-메서드Factory-Method-패턴-제대로-배워보자](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9CFactory-Method-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90))
- [제너릭이란? 1](https://www.nextree.io/generic-ihaehagi/)
- [제너릭이란? 2]([https://inpa.tistory.com/entry/JAVA-☕-제네릭Generics-개념-문법-정복하기](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0))
- [한정적 와일드카드 타입 1](https://mangkyu.tistory.com/241)
- [한정적 와일드카드 타입 2]([https://velog.io/@tamxt4047/한정적-와일드카드Bounded-Wildcard-Type](https://velog.io/@tamxt4047/%ED%95%9C%EC%A0%95%EC%A0%81-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9CBounded-Wildcard-Type))