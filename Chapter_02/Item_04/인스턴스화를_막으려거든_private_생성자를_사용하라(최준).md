# 4️⃣ Item 4: 인스턴스화를 막으려거든 private 생성자를 사용하라

<br>

## 📌 목차
1. 정적 멤버만 있는 유틸리티 클래스

2. 유틸리티 클래스의 인스턴스

3. 클래스의 인스턴스화 막는 방법

4. 방법 1. 추상 클래스로 만들기

5. 방법 2. private 생성자 추가하기

6. private 생성자 사용

<br>

## 🛠 정적 멤버만 있는 유틸리티 클래스

- `유틸리티 클래스 = 정적 멤버만 있다.` = 정적 메소드 & 정적 필드만 있다. 

- 유틸리티 클래스는 특정 작업 or 기능 수행하기 위해 재사용 가능한 메서드, 필드 제공하는 클래스다. 

- 객체 생성하지 않고도 **해당 클래스의 메서드 직접 호출해서 사용** 가능하다. 

- ***`객체 지향적으로 좋은 것은 아니라고 한다.`***

- 하지만 쓰임새가 있는 곳이 있다. 

<br>

### 👍 유틸리티 클래스 좋은 곳
유틸리티 클래스가 쓰임새가 있는 곳은 `3가지`가 있다. 

1. **기본 타입 값이나 배열 관련 메소드**들 모아 놓는 경우 

2. **특정 인터페이스 구현하는 객체 생성해주는 정적 메소드** 모아 놓는 경우

3. **final 클래스와 관련 메소드** 모아 놓는 경우 

<br>

- `유틸리티 클래스가 객체 지향적으로 좋지 않은 이유는?`

      1. 유틸리티 클래스는 정적 메소드만으로 이뤄져 있어 객체의 상태 저장할 수 있는 인스턴스 변수가 없다. 
      
      따라서 객체 지향적 설계에서 캡슐화를 위반하는 것으로 간주될 수 있다. 
    
      2. 상속 받거나 인터페이스를 구현할 수 없다. 
    
      3. 유틸리티 클래스 사용하는 경우 유릴리티 클래스에 강한 의존성 갖게 된다. 
    
      추상화 진행하지 않아 유틸리티 클래스의 변화에 많은 영향 받게 된다. 
    
      4. 유틸리티 사용하는 클래스는 원래 책임 말고토 유틸리티 클래스의 종속성도 얻는다. 
    
      객체 지항적 설계 원칙의 단일 책임 원칙 무시하는 것이다. 

<br>

## 🗑 유틸리티 클래스의 인스턴스

유틸리티 클래스는 `인스턴스로 만들어 쓰라고 설계한 것이 아니다.` 

하지만 생성자 명시하지 않으면 자동으로 기본 생성자가 생긴다. 

그러면 사용자는 이 `생성자가 명시된 것인지 자동 생성된 것인지 모른다.` 

그렇다면 유틸리티 클래스의 `인스턴스화를 막으려면` 어떻게 해야 하는가?

인스턴스화를 막는 방법에 대해서 알아보자. 

<br>

## 🚫 클래스의 인스턴스화 막는 방법

1. 추상 클래스로 만들기

2. private 생성자 추가하기

<br>

## 1️⃣ 방법 1. 추상 클래스로 만들기

자바에서 인스턴스화 막을 수 있는 가장 간단한 방법하면 떠오르는 방법이다. 

`추상 클래스는 인스턴스를 생성할 수 없으니` 인스턴스화 막을 수 있겠다고 생각할 수 있다. 

하지만 이 방법은 ***`인스턴스화를 막을 수 없다.`***

왜냐하면 `하위 클래스 만들어서 인스턴스화` 하면 된다. 

이렇게 하면 더 문제가 사용자가 추상 클래스이니 상속해서 사용하라는 뜻이라고 이해할 수 있다. 

<br>

- `추상 클래스란?`
    
      하나 이상의 추상 메소드를 포함하는 클래스이다.
    
      추상 메소드란 자식 클래스에서 반드시 오버라이딩 해야 사용할 수 있는 메소드다. 
    
      선언부만 존재하며 구현부는 없다. 
    
      객체 지향 프로그래밍에서 중요한 특징인 다형성 가지는 메소드의 집합 정의할 수 있게 해준다. 
    
      이 클래스를 상속 받는 모든 클래스에서는 이 추상 메소드를 반드시 정의 해야 한다. 
    
      추상 메소드를 포함하고 있어 인스턴스를 생성할 수 없다. 
    
      인스턴스를 생성하려면 상속을 통해 자식 클래스 만들고 자식 클래스에서 모든 추상 메소드를 오버라이딩 해야 한다. 
    
      추상 클래스와 추상 메소드는 아래와 같이 생겼다. 
    
    ```java
    //추상 클래스라 앞에 abstract 키워드 있음
    abstract class ClassName{

    	//추상 메소드라 abstract 클래스 있고 구현부가 존재하지 않음
    	abstract type methodName();
        
    }
    ```

<br>

## 2️⃣ 방법 2. private 생성자 추가하기

따라서 인스턴스화를 막으려면 `private 생성자를 추가하는 방법을 사용`해야 한다. 

컴파일러가 기본 생성자를 만드는 경우는 명시된 생성자가 없을 때이다. 

그러면 명시된 생성자를 만들어야 한다. 

하지만 명시된 생성자를 public, protected로 만들면 어디선가 인스턴스를 만들 수 있다. 

따라서 `private 생성자를 추가하면 클래스의 인스턴스화를 막을 수 있다.` 

private 생성자는 아래와 같이 사용한다. 

```java
public class UtilityClass{

	private UtilityClass(){~}
	....
}
```

<br>

## 🚧 private 생성자 사용

private 생성자를 만들면 클래스 안에서 실수로라도 생성자를 호출하지 않게 해준다. 

따라서 `어떤 환경에서도 클래스가 인스턴스화 되는 것을 막아준다.` 

하지만 생성자가 있는데 호출할 수 없으니 직관적이지 않다. 

따라서 아래 코드처럼 `적절한 주석을 달아두자.` 

```java
public class UtilityClass{

	// 기본 생성자가 만들어지는 것을 막는다. (인스턴스화 방지용)
	private UtilityClass(){
		throw new AssertionError();
	}
	....
}
```

private 생성자를 사용하면 `상속을 불가능하게 하는 효과`가 있다. 

모든 생성자는 상위 클래스 생성자 호출하는데 private라 호출할 수가 없다. 

따라서 하위 클래스가 상위 클래스의 생성자에 접근하는 길이 막힌다. 

이렇기 때문에 위에서 유틸리티 클래스가 `객체 지향적으로 좋지 않은 이유`가 나오는 것이다. 

<br>

## 📍 references

- [유틸리티 클래스와 객체 지향적 설계 1](https://be-study-record.tistory.com/39)
- [유틸리티 클래스와 객체 지향적 설계 2](https://hamryt.tistory.com/2)
- [추상 클래스란? 1](https://limkydev.tistory.com/188)
- [추상 클래스란? 2](https://tcpschool.com/java/java_polymorphism_abstract)