# 6️⃣ Item 6: 불필요한 객체 생성을 피하라

<br>

## 📍 목차
1. 불필요한 객체 생성
2. 예제 1
3. 예제 2
4. 예제 3
5. 예제 4
6. 객체 재사용
7. 객체 재사용...?
8. 정리

<br>

## 🤔 불필요한 객체 생성

똑같은 기능의 객체를 매번 생성하기보다는 `객체 하나 재사용하는 것`이 나을 때가 많다. 

재사용은 빠르고 세련된다. 

지금부터 `불필요하게 객체가 생성되는 경우`를 볼 것이다. 

그리고 그런 경우 `어떻게 불필요한 객체 생성을 피할 수 있는지` 볼 것이다. 

<br>

## 1️⃣ 예제 1

### 불필요하게 객체 생성되는 경우

먼저 극단적인 예시를 보자. 

```java
String s = new String("bikini");
```

이렇게 하면 `실행될 때마다 String 인스턴스를 새로` 만든다. 

`String 생성자를 사용`해서 String을 만들고 있기 때문이다. 

생성자에 넘기는 값이 생성자로 만들려는 것과 똑같기 때문에 완전히 쓸데없는 행위이다. 

아무도 String을 사용할 때 이렇게 사용하지 않는다. 

<br>

### 불필요한 객체 생성 피하는 법

String을 사용할 때 아래처럼 대부분 **문자열 리터럴을 사용**해 선언한다. 

이렇게 사용해야 `불필요한 String 객체 생성을 피할 수 있다.` 

```java
String s = "bikini";
```

이렇게 하면 매번 새로운 인스턴스를 만드는 대신 `하나의 String 인스턴스를 사용`한다. 

그리고 같은 가상 머신 안에서 이것과 똑같은 문자열 리터럴을 사용하는 모든 코드가 `같은 객체를 재사용함이 보장`된다. 

<br>

- **`String 동작 방식`**
    
      String은 Heap 메모리 영역에 String만을 위한 전용 메모리 공간이 있다. 
    
      이 공간을 String contant pool = 문자열 상수 풀이라고 한다. 
    
      String의 선언 방식이 생성자를 통한 선언 방식이 아니라 위처럼 리터럴로 선언하는 방식이면 JVM은 String contant pool에서 같은 값이 있는지 찾아본다. 
    
      같은 값이 있다면 String 인스턴스가 pool 안에 있는 값을 바라보게 된다. 
    
      따라서 동일한 문자열 리터럴 사용하면 새로운 메모리 공간이 할당되지 않고 저장된 주소를 참조하는 것이다. 
    
      하지만 다른 문자열 리터럴 사용하면 문자열 리터럴이 문자열 상수 풀에 들어가고 새로운 String 객체가 생성되고 그 문자열 리터럴을 가리키게 되는 것이다. 
    
    ![image](https://hyungjoon6876.github.io/jlog/assets/img/201808/string_pool.png)
    
<br>

## 2️⃣ 예제 2

### 불필요하게 객체 생성되는 경우

아래와 같은 경우처럼 `생성자를 사용하면 불필요하게 객체가 생성`이 된다. 

```java
Boolean tf = new Boolean("true")
```

Boolean 생성자는 파라미터가 “true”이면 true를 반환하고 “false”이면 false를 반환하고 이외의 문자열이면 예외를 발생한다고 한다. 

이 생성자는 자바 9에서 사용 자제 = deprecated API로 지정되었다고 한다. 

<br>

### 불필요한 객체 생성 피하는 법

이런 불필요한 객체 생성 피하려면 정적 팩토리 메소드를 제공하는 불변 클래스에서는 `생성자 대신 정적 팩토리 메소드를 사용`하면 된다.

아래처럼 사용하면 되는 것이다. 

```java
Boolean tf = Boolean.valueOf("true")
```

생성자는 호출할 때마다 새로운 객체 만들지만 팩토리 메소드는 그렇지 않다. 

<br>

## 3️⃣ 예제 3

### 불필요하게 객체 생성되는 경우

생성 비용이 아주 비싼 객체가 있다. 

이런 `비싼 객체가 반복해서 필요하면 캐싱해서 재사용`하기를 권한다. 

하지만 ***`만드는 객체가 비싼 객체인지 매번 명확히 알 수 없다.`*** 

아래의 예시는 생성 비용 비싼 객체가 계속 만들어지는 경우다. 

```java
// 코드 6-1 성능을 훨씬 더 끌어올릴 수 있다!
static boolean isRomanNumeralSlow(String s) {
	return s.matches("^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```
<br>

코드를 보면 new 키워드도 안 보이고 객체가 만들어지는 곳이 없어 보인다. 

이것이 문제로 `어디서 객체가 생성되는지 알 수가 없다.` 

String.matches 메소드를 사용하는 곳이 문제이다. 

String.matches 메소드는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이지만 성능이 중요한 곳에서는 반복 사용하기에는 적합하지 않다. 

왜냐하면 이 `메소드 내부에서 정규표현식용 Pattern 인스턴스를 만든다.` 

Pattern 인스턴스는 한번 사용하고 바로 버려진다. 

Pattern 인스턴스는 입력 받은 정규표현식에 해당하는 유한 상태 머신을 만들기 때문에 `인스턴스 생성 비용이 높다.` 

이렇게 메소드 내부에서 인스턴스를 만들어서 객체가 생성되는지 알 수 없다.

```java
public boolean matches(String regex) {
	return Pattern.matches(regex, this);
}
```

<br>

- **`유한 상태 머신`**
    
      유한 상태 머신(Finite State Machine, FSM)은 컴퓨터 과학 및 이산 수학에서 사용되는 추상적인 모델이다. 
    
      이 모델은 유한한 수의 상태(state)와 이러한 상태들 간의 전이(transition)를 표현한다.
    
      유한 상태 머신은 문자열 매칭을 하기 위해 입력 문자열을 한 글자씩 읽으며, 현재 상태에 따라 다음 상태로 이동한다. 
    
      이를 통해 특정 패턴을 인식하거나 찾을 수 있다.
    
      즉 정규 표현식에 해당하는 유한 상태 머신을 만든다. 
    
      문자열을 유한 상태 머신에 넣어 진행했을 때 최종 상태에 도달하면 그 문자열은 해당 정규 표현식에 매칭되는 문자열이다. 
    
    ![image](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/DFA-powerset-construction-example.svg/300px-DFA-powerset-construction-example.svg.png)

<br>    

### 불필요한 객체 생성 피하는 법

불필요한 객체 생성을 피해서 성능을 개선하려면 어떻게 해야 하는지 보자.

바로 `Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해둔다.` 

그리고 나중에 메소드 호출될 때마다 `인스턴스 재사용`하면 된다. 

```java
// 코드 6-2 값비싼 객체를 재사용해 성능을 개선한다.
private static final Pattern ROMAN = Pattern.compile(
	"^(?=.)M*(C[MD]|D?C{0,3})" + "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

static boolean isRomanNumeralFast(String s) {
	return ROMAN.matcher(s).matches();
}
```
<br>

이렇게 개선한 후 길이 8인 문자열 입력했을 때 `6.5배` 정도 빨라진다고 한다. 

그리고 성능만 좋아진 것이 아니라 `코드도 더 명확`해지는 효과가 있다. 

왜냐하면 개선 전에는 존재도 몰랐던 Pattern 인스턴스를 `필드로 꺼내 코드의 의미가 들어난다.` 

이 방식은 클래스가 초기화된 후 isRomanNumeralFast 메소드를 한번도 호출하지 않으면 Pattern 인스턴스는 쓸데없이 초기화된 꼴이다. 

메소드가 처음 호출될 때 Pattern 인스턴스를 초기화 하는 지연 초기화 방법이 있지만 코드는 복잡해지는데 성능은 크게 개선되지 않을 때가 많아 권하지는 않는다고 한다. 

<br>

## 4️⃣ 예제 4

### 불필요하게 객체 생성되는 경우

`오토박싱 기술을 사용할 때 또 불필요하게 객체가 생성`된다. 

오토박싱이란 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 **자동으로 상호 변환해주는 기술**이다. 

<br>

- **`박싱된 기본 타입이란?`**
    
      박싱된 기본 타입은 기본 타입을 해당하는 참조 타입으로 감싼 것이다. 
    
        기본 타입 : int, double, boolean…
    
        박싱된 기본 타입 : Integer, Double, Boolean
    
      기본 타입 값을 가지는 변수를 박싱해 박싱된 기본 타입 클래스의 객체로 만드는 것이다. 
    
      기본 타입은 값만 가지고 있지만 박싱된 기본 타입은 값에 더해 식별성이란 속성 가진다 .
    
      박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다. 
    
<br>

의미상으로는 별다를 것이 없어 보이지만 성능은 그렇지 않다. 

아래 코드에서 오토박싱이 일어나서 불필요하게 객체가 생성된다. 

```java
// 코드 6-3 끔찍이 느리다! 객체가 만들어지는 위치를 찾았는가? 
    private static long sum() {
        Long sum = 0L;
        for (long i = 0; i <= Integer.MAX_VALUE; i++)
            sum += i;
        return sum;
    }
```

<br>
 
코드를 보면 박싱된 기본 타입인 Long sum 변수를 선언했다. 

그리고 for문에서 long i 변수를 선언하고 for문 안에서 sum 변수에 i를 계속 더하고 있다. 

이때 `long i 변수가 Long으로 오토박싱` 되는 것이다. 

그 과정에서 `Long 객체가 계속 생성`되는 것이다. 

```java
sum += new Long(i)
```

sum 변수를 long 타입이 아닌 Long 타입으로 선언해서 Long 인스턴스가 2^31개나 만들어진다. 

이렇게 엄청난 개수의 `불필요한 객체가 생성되면서 성능이 엄청 떨어지는 것이다. `

<br>

### 불필요한 객체 생성 피하는 법

불필요한 객체 생성을 피하려면 `박싱된 기본 타입보다 기본 타입을 사용`하면 된다. 

이렇게 기본 타입을 사용하면 속도가 `1/6배` 된다. 

따라서 박싱된 기본 타입보다 `기본 타입 사용하고 의도치 않은 오토 박싱이 숨어들지 않게 주의`하자. 

<br>

## ♻ 객체 재사용

이렇게 `불필요한 객체 생성을 피하는 방법`들이 있다. 

아래는 위의 방법들을 정리한 것이다. 

1. String에서 생성자로 선언이 아닌 문자열 리터럴로 선언해 객체를 재사용한다. 

2. 생성자가 아닌 정적 팩토리 메소드를 사용해 객체를 재사용한다. 

3. 인스턴스를 클래스 초기화 과정에서 직접 생성 후 캐싱해 나중에 인스턴스 재사용한다. 

4. 박싱된 기본 타입보단 기본 타입을 사용해 불필요한 객체 생성을 피한다. 

<br>

String, Boolean 이런 클래스들은 불변 객체이다. 

이렇게 `객체가 불변이라면 재사용해도 안전`하기 때문에 1, 2번 방법에서 재사용하는 것이다. 

<br>

## ❓ 객체 재사용…??
하지만 이렇게 `재사용 하면 덜 명확하거나 심지어 직관에 반대되는 상황`도 있다. 

***`어댑터 패턴`*** 이 이런 상황이다. 

<br>

### 🗣 어댑터 패턴

어댑터 패턴은 `한 구현체를 다른 인터페이스에 맞게 감싸주는 것`이다. 

Adapter는 실제 작업은 뒷단 객체 Adaptee에게 위임하고 Adapter는 제2의 인터페이스 역할을 해주는 객체다. 

Adapter는 Adaptee만 관리하면 되어서 `Adaptee 하나당 Adapter 하나씩만 만들어지면 충분`하다. 

`Adapter는 하나만 만들어서 재사용`하면 된다. 

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FboRyyV%2FbtrXrOg3fZN%2FUcYclEofdmvZnCMfMBCa8K%2Fimg.png)

<br>

### 🙎‍♂️ 어댑터 패턴 예시
예시로 이해해보자. 

Map 인터페이스의 keySet 메소드는 Map 객체 안의 키 전부를 담은 Set 뷰를 반환한다. 

`Set이 Adapter의 역할`을 하는 것이다. 

keySet 메소드를 호출할 때마다 `새로운 Set 인스턴스 만들어질 것 같다.` 

하지만 매번 ***`같은 Set 인스턴스를 반환`*** 한다. 

왜냐하면 Set 인스턴스들이 기능적으로 모두 똑같다. 

모두 똑같은 Map 인스턴스를 대변해서 반환된 Set 객체 중 하나 수정하면 다른 모든 객체가 따라서 바뀐다. 

그래서 모두 똑같아야 하기 때문에 keySet 메소드가 `Set 인스턴스를 여러 개 만들어도 상관 없지만 그렇게 하지 않는 것`이다. 

Set 인스턴스 여러 개 만들 필요도 없고 이득도 없다. 

<br>

아래 코드는 keySet을 여러 번 호출해 같은 Set 인스턴스인지 확인한 것이다. 

그리고 Set 인스턴스 하나에 변화를 줬을 때 다 적용되는지 확인해 본 것이다. 

<br>

---
**`코드`**

```java
public static void main(String[] args) {
        Map map = new HashMap<Integer, String>();

        map.put(0, "00");
        map.put(1, "11");
        map.put(2, "22");
        map.put(3, "33");

        Set<Integer> set1 = map.keySet();
        System.out.println("set1 인스턴스 주소: "+ System.identityHashCode(set1));

        Set<Integer> set2 = map.keySet();
        System.out.println("set2 인스턴스 주소: "+ System.identityHashCode(set2));

        System.out.println();
        System.out.println("set 1 값: " + set1);
        System.out.println("set 2 값: " + set2);

        set1.remove(3);

        System.out.println();
        System.out.println("set 1 변경 후");
        System.out.println("set 1 값: " + set1);
        System.out.println("set 2 값: " + set2);

        System.out.println();
        Set<Integer> set3 = map.keySet();
        System.out.println("set3 인스턴스 주소: "+ System.identityHashCode(set3));
    }
```

<br>

**`결과`**

```java
set1 인스턴스 주소: 1324119927
set2 인스턴스 주소: 1324119927

set 1 값: [0, 1, 2, 3]
set 2 값: [0, 1, 2, 3]

set 1 변경 후
set 1 값: [0, 1, 2]
set 2 값: [0, 1, 2]

set3 인스턴스 주소: 1324119927
```
---

<br>

### 🙋‍♂️ 객체 재사용...? 이유
직관에는 Set 인스턴스를 `keySet 메소드 호출할 때마다 새로 생성할 것 같다.` 

그래서 위의 코드에서 set 1만 수정했을 때 `set 1만 수정 될 것`이라고 생각이 된다. 

하지만 Set이 Adapter이기 때문에 `하나만 만들어서 재사용`하면 된다. 

그리고 Set 인스턴스가 Map 인스턴스를 대변해서 여러 개를 만들면 논리적으로도 이상하다. 

그래서 `객체를 재사용해서 직관에 반대되고 명확하지 않은 것`이다. 

직관에는 set 1만 수정될 것이라고 생각하는데 set 2도 같이 수정이 된 것이다. 

<br>

## ❗ 정리

이렇게 `불필요한 객체 생성을 피해야 한다.` 

하지만 ‘객체 생성은 비싸니 무조건 피해야 한다’ 이렇게 `오해하면 안된다.`

요즘 JVM에서는 작은 객체를 생성하고 회수하는 일이 `크게 부담되지는 않는다.`

프로그램의 명확성, 간결성, 기능 위해서 객체를 추가로 생성하는 것이라면 일반적으로 좋은 일이다. 

그리고 아주 무거운 객체가 아니면 단순히 객체 생성 피하고자 `객체 풀을 만들지 말자. `

객체 풀을 만드는게 나은 예가 있기는 한데 `일반적으로 자체 객체 풀은 문제가 많다.` 

1. 코드 헷갈리게 만든다. 

2. 메모리 사용량을 늘린다.  

3. 성능 떨어뜨린다. 

<br>

요즘 `JVM의 가비지 컬렉터는 잘 최적화 되어서 가벼운 객체를 다룰 때에는 직접 만든 객체 풀보다 훨씬 빠르다.` 

<br>

- **`객체 풀이란?`**
    
      객체 풀의 의도는 객체를 매번 할당, 해제하지 않고 고정 크기 풀에 들어있는 객체를 재사용해서 메모리 사용 성능을 개선하는 것이다. 
    
      처음에 한 번 메모리를 크게 잡아놓고 계속 들고 있으면서 객체 풀 안에서 객체를 할당, 해제를 자유롭게 할 수 있는 것이다. 
    
      재사용 가능한 객체들을 모아놓은 객체 풀 클래스를 정의한다. 
    
      객체 풀에 객체를 미리 ‘사용 안함’ 상태로 선언하고 필요할 때마다 객체 풀에 객체 달라고 요구하는 것이다. 
    
      그렇게 되면 풀에서 객체 선택해 ‘사용 중’ 상태로 바꾼 뒤 객체를 반환한다. 
    
<br>

방어적 복사에서는 ‘새로운 객체를 만들어야 한다면 기존 객체를 재사용 하지 마라’ 라고 말한다. 

`방어적 복사가 필요한 상황에서 객체 재사용했을 때의 피해가 필요 없는 객체를 반복 생성했을 때의 피해보다 훨씬 크다. `

방어적 복사에 실패하면 언제 터질지 모르는 버그와 보안 구멍으로 이어진다.

하지만 불필요한 객체 생성은 코드 형태와 성능에만 영향을 준다. 

<br>

- **`방어적 복사란?`**
    
      내부의 객체를 반환할 때, 객체의 복사본을 만들어서 반환하는 것을 방어적 복사라고 한다.
    
      방어적 복사를 하게 되면, 복사한 외부의 객체를 변경해도 원본 내부 객체가 변경되지 않는다.
    
      생성자의 인자로 받은 객체의 복사본을 만들어 내부 필드를 초기화하거나, getter메서드에서 내부의 객체를 반환할 때, 객체의 복사본을 만들어 반환하는 것이다.
    
      방어적 복사는 객체의 취약점을 방어하기 위해 사용한다.
    
<br>

***`따라서 무조건 객체 생성을 피하는 것이 아니라 불필요한 객체 생성을 줄이자는 것이다.`*** 

<br>

## 📍 references

- [String 동작 방식1]([https://velog.io/@gates/JAVA-String-클래스에-대해서-알아보자](https://velog.io/@gates/JAVA-String-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90))

- [String 동작 방식2](https://hyungjoon6876.github.io/jlog/2018/08/09/java-string.html)

- [String 동작 방식3](https://aljjabaegi.tistory.com/465)

- [박싱된 기본 타입](https://xonmin.tistory.com/29)

- [객체 풀](https://luv-n-interest.tistory.com/1116)

- [방어적 복사 1](https://ksh-coding.tistory.com/77)

- [방어적 복사 2]([https://velog.io/@miot2j/얕은복사-깊은복사-방어적-복사란](https://velog.io/@miot2j/%EC%96%95%EC%9D%80%EB%B3%B5%EC%82%AC-%EA%B9%8A%EC%9D%80%EB%B3%B5%EC%82%AC-%EB%B0%A9%EC%96%B4%EC%A0%81-%EB%B3%B5%EC%82%AC%EB%9E%80))

- [어댑터 패턴](https://jake-seo-dev.tistory.com/379)