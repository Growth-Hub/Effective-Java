# 1️⃣ Item1: 생성자 대신 정적 팩토리 메서드를 고려하라

<br>

## 🆕 클래스 인스턴스 얻는 방법

>1. public 생성자
>   
>2. 정적 팩토리 메소드

정적 팩토리 메소드는 `클래스의 인스턴스를 반환하는 단순한 정적 메소드`다. 

정적 팩토리 메소드는 디자인 패턴의 팩토리 메소드 패턴과 다른 것이다. 

### 정적 팩토리 메소드 예시 

1. 정적 팩토리 메소드에서 **객체를 새로 생성**해주는 것

```java
public final class Optional<T> {

    private final T value;

    private Optional(T value) {
        this.value = value;
    }

    public static <T> Optional<T> of(T value) {
        return new Optional<>(Objects.requireNonNull(value));
    }
```

2. **만들어진 객체**를 정적 팩토리 메소드에서 **반환**해주는 것 

```java
public final class Boolean implements java.io.Serializable,
                                      Comparable<Boolean>, Constable
{
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    
    public static Boolean valueOf(boolean b) {
        return (b ? TRUE : FALSE);
    }
```

<br>

## 👍 정적 팩토리 메소드 장점

1. 이름 가질 수 있다. 
2. 호출될 때마다 인스턴스 새로 생성하지 않아도 된다.
3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다. 
4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다. 
5. 정적 팩토리 메소드 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다. 

각 장점에 대해서 보자. 

<br>

### 1️⃣ **장점 1. 이름을 가질 수 있다.**
생성자의 매개변수와 생성자 만으로는 반환될 객체의 특성 제대로 이해할 수 없다.

하지만 정적 팩토리 메소드는 `이름을 잘 지으면 반환될 객체의 특정 쉽게 묘사 할 수 있다.` 

‘값이 소수인 BigInteger를 반환’하는 생성자와 정적 팩토리 메소드를 보자. 

아래만 봐도 어떤 것이 반환될 객체를 이해하는데 쉬운지 알 수 있다.

>Probable = 가능성 있는
>
>Prime = 소수

```java
BigInteger(int, int, Random)

BigInteger.probablePrime(int, Random)
```

또한 `생성자들은 각각의 차이를 알기 어렵다. `

하나의 시그니처 (메소드 이름 + 파라미터)로 생성자 하나만 만들 수 있다. 

매개변수 순서 다르게 해서 같은 시그니처로 여러 생성자 만들 수 있지만 이렇게 하면 정확히 기억하기 어렵고 어떤 의미인지 알기 어렵다. 

```java
Car(int, String)

Car(String, int) 

....?
```

이렇게 ***시그니처 같은 생성자 여러 개 필요할 것 같으면 생성자 대신 정적 팩토리 메소드 사용하자.***

그리고 각각의 차이를 잘 드러내는 메소드 이름을 지어주면 된다. 

<br>

### 2️⃣ **장점 2. 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.**
`객체를 미리 생성해 두고 정적 팩토리 메소드 호출해서 반환` 받을 수 있다.

생성자를 사용하면 객체가 계속 생성이 되어 불필요한 객체가 생성이 된다. 

이런 방식의 정적 팩토리 메소드를 통해 `immutable class는 불필요한 객체 생성을 피한다.` 

이 장점 때문에 생성 비용이 큰 같은 객체가 자주 요청되는 상황에서 성능을 올릴 수 있다. 

- **`Immutable class란?`**

      대표적으로 String, Boolean, Integer 등이 있다. 
    
      Immutable class는 레퍼런스 타입 객체라 heap 영역에 생성된다. 
    
      Immutable class는 heap 영역에서 변경 불가능한 것이지 재할당 못하는 것이 아니다. 
    
      String a=”aa” → a=”bb” 처럼 재할당 = 값을 바꾸면 값이 바뀌는 것이 아니라 객체가 바뀌는 것이다. 
    
      a가 참조하던 “aa” 값이 “bb”로 바뀌는 것이 아니라 “bb”라는 객체를 만들고 이것을 a가 참조하는 것이다. 
    
<br>

정적 팩토리 방식의 클래스는 인스턴스를 통제할 수 있는데 이런 클래스를 인스턴스 통제 클래스라고 한다. 

❓ **인스턴스 통제하는 이유는 뭔가?**

1. 클래스 싱클톤으로 만들 수 있음

2. 인스턴스화 불가로 만들 수 있음

3. immutable class에서 같은 인스턴스가 단 하나뿐임을 보장할 수 있다. 

이런 `인스턴스 통제는 플라이웨이트 패턴의 근간이 된다.` 

- **`플라이웨이트 패턴이란?`**
    
      재사용 가능한 객체 인스턴스를 공유시켜 메모리 사용량을 최소화하는 구조 패턴이다. 
    
      간단히 말하면 캐시(Cache) 개념을 코드로 패턴화 한것으로 보면 된다.
    
      자주 변하는 속성(extrinsit)과 변하지 않는 속성(intrinsit)을 분리하고 변하지 않는 속성을 캐시하여 재사용해 메모리 사용을 줄이는 방식이다. 
    
      그래서 동일하거나 유사한 객체들 사이에 가능한 많은 데이터를 서로 공유하여 사용하도록 하여 최적화를 노리는 경량 패턴이라고도 불린다.
    
      new 연산자를 통한 메모리 낭비를 줄이는 방식이다. 
    
<br>

### 3️⃣ **장점 3. 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
이것은 `반환할 객체의 클래스를 자유롭게 선택`할 수 있게 하는 유연성 준다.

이 능력이 있기 때문에 정적 팩토리 메소드의 반환 타입을 인터페이스로 하고 하위 객체인 구현 객체를 받을 수 있다. 

이 능력으로 `API 만들 때 구현 클래스 공개하지 않고도 구현 객체 반환`할 수 있어 `API 작게 유지`할 수 있다. 

API가 작아지면 프로그래머가 API 사용하기 위해 익혀야 하는 개념의 수와 난이도도 낮춘 것이다. 

프로그래머는 명시한 인터페이스대로 동작하는 객체를 얻는 것 아니까 실제 구현 클래스가 뭔지 알아보지 않아도 된다. 

생성자를 사용했으면 실제 구현 클래스가 뭔지 알아야 한다. 

new 구현 클래스(); 해야 하기 때문이다. 

그리고 얻은 객체를 `구현 클래스가 아닌 인터페이스만으로 다루는데 이것은 좋은 습관`이다. 

<br>

### 4️⃣ **장점 4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
`반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환해도 상관 없다.`

이렇게 하면 `추후에 하위 클래스를 삭제하거나 추가해도 문제가 없다.` 

아래는 EnumSet 클래스의 정적 팩토리 메소드이다. 

조건에 따라 다른 하위 타입의 클래스를 반환하고 있다. 

추후에 변경이 필요하면 if문을 추가하거나 제거하면 된다. 

```java
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {

				...

        if (universe.length <= 64)
            return new RegularEnumSet<>(elementType, universe);
        else
            return new JumboEnumSet<>(elementType, universe);
    }
```

클라이언트는 건네주는 객체가 어떤 클래스의 인스턴스인지 알 수도 없고 알 필요도 없다. 

그냥 반환 타입의 하위 타입이기만 하면 된다. 

<br>

### 5️⃣ **장점 5. 정적 팩토리 메소드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
이런 유연함은 `서비스 제공자 프레임워크 (service provider framework)`를 만드는 근간이 된다.

아래의 서비스 제공자 프레임워크에 서비스 접근 API가 정적 팩토리 메소드이다. 

<br>

**🗣 서비스 제공자 프레임워크란?**

>서비스 제공자 프레임워크는 확장 가능한 자바 어플리케이션 만드는 패턴 중 하나다.
>
>외부에서 클라이언트에게 `Jar 파일 받아 기존 코드의 변경 없이 기능을 확장`할 수 있다. 
>
>서비스 제공자 프레임워크는 `서비스의 구현체들을 클라이언트에 제공하는 역할을 프레임워크가 통제`하는 것이다. 
>
>따라서 클라이언트를 구현체로부터 분리해주는 것이다. 
>
>서비스 제공자 프레임워크는 3개의 핵심 컴포넌트와 1개의 추가 컴포넌트로 이뤄진다. 
>
>1. 서비스 인터페이스 : 구현체의 동작을 정의
>
>2. 제공자 등록 API : 제공자가 구현체를 등록할 때 사용
>
>3. 서비스 접근 API : 클라이언트가 서비스의 인스턴스 얻을 때 사용
>
>4. 서비스 제공자 인터페이스 : 서비스 인터페이스의 인스턴스 생성하는 팩토리 객체 설명
>
>클라이언트는 서비스 접근 API 사용할 때 원하는 구현체의 조건 명시할 수 있다. 
>
>조건 명시하지 않으면 기본 구현체 반환하거나 지원하는 구현체들 하나씩 돌아가며 반환한다. 
>
>서비스 제공자 프레임워크 패턴에는 여러 변형이 있다. 
>1. 브리지 패턴
>
>2. 의존 객체 주입 프레임워크

<br>

## 👎 정적 팩토리 메소드 단점
1. `상속` 하려면 public or protected 생성자가 필요해 정적 팩토리 메소드만 제공하면 하위 클래스 만들 수 없다. 

2. 정적 팩토리 메소드는 `프로그래머가 찾기 어렵다`. 

<br>

### 1️⃣ **단점 1. 상속 하려면 public or protected  생성자 필요해 정적 팩토리 메소드만 제공하면 하위 클래스 만들 수 없다.**
말 그대로 `상속하려면 정적 팩토리 메소드만으로는 안된다`는 것이다.

하지만 이 단점은 오히려 장점으로 받아질 수도 있는데 그 이유는 아래와 같다. 

1. 상속보다 컴포지션을 사용하도록 유도

2. immutable class type으로 만들려면 이 제약 지켜야 함

- **`컴포지션이란?`**
    
      상속은 extends를 활용해 자식 클래스를 부모 클래스에서 파생 시키는 것이다. 
    
      상속은 상위 클래스와 하위 클래스가 “is a”, “is a kind of” 관계일 때 사용한다. 
    
      ex) 사람 is a 동물
    
      컴포지션은 클래스에 필드로 다른 클래스의 인스턴스를 가지고 있는 것이다. 
    
      컴포지션은 한 객체가 다른 객체를 “has”, “is part of” 할 때 사용한다. 
    
      ex) 바퀴 is a part of 자동차
    
<br>

### 2️⃣**단점 2. 정적 팩토리 메소드는 프로그래머가 찾기 어렵다.**
생성자처럼 API 설명에 명확히 드러나지 않으니 `정적 메소드 팩토리 메소드 방식으로 클래스를 인스턴스화 할 방법을 알아내야 한다.`

그래서 `API 문서 잘 작성`하고 정적 팩토리 `메소드 이름도 알려진 규약을 따라 지어야 한다`. 

아래는 정적 팩토리 메소드에서 흔히 사용하는 명명 방식이다. 

- `from`: 매개변수 하나 받아 해당 타입 인스턴스 반환하는 형변환 메소드에 사용

- `of`: 여러 매개 변수 받아 적합한 타입의 인스턴스 반환하는 집계 메소드에 사용

- `valueOf`: from, of의 더 자세한 버전

- `instance / getInstance`: 매개변수로 명시한 인스턴스 반환하지만 같은 인스턴스임을 보장하지 않는 메소드에 사용

- `create / newInstance`: instance / getInstance와 같지만 매번 새로운 인스턴스 생성해 반환함을 보장하는 메소드에 사용

- `get’Type’`: getInstance와 같으나 생성할 클래스가 아닌 다른 클래스의 팩토리 메소드 정의할 때 사용

- `new’Type’`: newInstance와 같으나 생성할 클래스가 아닌 다른 클래스의 팩토리 메소드 정의할 때 사용

- `‘type’`: getType, newType의 간결한 버전

(여기서 ‘type’은 팩토리 메소드가 반환할 객체의 타입이다. ex: getCar, newCar)
    
<br>

## ✅결론
정적 팩토리 메소드와 public 생성자는 각자의 쓰임새 있으니 `장단점 이해하고 사용`하는 것이 좋다. 

그래도 `정적 팩토리 메소드 사용하는 것이 유리한 경우가 더 많으니` 무작정 public 생성자 제공하던 습관이 있다면 고치자.

<br>

## 📍 references

- [flyweight 디자인 패턴 1](https://velog.io/@ddh963963/GoF-%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-Flyweight)

- [flyweight 디자인 패턴 2](https://lee1535.tistory.com/106)

- [flyweight 디자인 패턴 3](https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-Flyweight-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90)

- [immutable class](https://limkydev.tistory.com/68)

- [정적 팩토리 메소드 예시 1](https://mysterlee.tistory.com/55)

- [정적 팩토리 메소드 예시 2](https://developer-nyong.tistory.com/28)

- [정적 팩토리 메소드 예시 3](https://7942yongdae.tistory.com/147)

- [인스턴스 캐싱](https://tecoble.techcourse.co.kr/post/2020-06-24-caching-instance/)

- [서비스 제공자 프레임워크 1](https://sihyung92.oopy.io/java/service-provider-framework#d21422e5-c553-4a3b-a31b-0547807e443e)

- [서비스 제공자 프레임워크 2](https://objeto.tistory.com/30)

- [서비스 제공자 프레임워크 3](https://velog.io/@jihoson94/Service-Provider-Framework-Interface)

- [상속 & 컴포지션](https://velog.io/@vino661/%EC%83%81%EC%86%8D%EA%B3%BC-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C)