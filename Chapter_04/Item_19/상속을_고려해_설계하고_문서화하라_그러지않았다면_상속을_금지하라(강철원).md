
"상속을 위한 설계와 문서화는 신중하게 하거나 아예 금지하라"에서는 자바 개발자가 클래스 설계와 상속에 있어서 중요한 지침을 제공합니다.  이 지침은 클래스가 다른 클래스에 의해 상속될 때 발생할 수 있는 여러 문제를 방지하기 위한 것 입니다.  

상속을 허용하는 클래스를 설계할 때는 다음과 같은 주요 권장 사항을 따라야 합니다.

## 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야합니다.

클래스는 자신이 어떤 오버라이드 가능한 메서드를 어떤 순서로, 어떤 결과를 기대하며 호출하는지 문서화해야 합니다. 이는 `@implSpec` 태그를 이용하면 조금 더 쉽게 문서화 할 수 있습니다.  


API 문서의 메서드 설명 끝에서 종종 implementation Requirements로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳 입니다.
이 절은 메서드 주석에 @implSpec 태그를 붙여주면 자바독 도구가 생성해줍니다. 

>다음은 java.util.AbstractCollection에서 발췌한 예입니다. 
![](https://i.imgur.com/OaI4j5t.png)
![](https://i.imgur.com/7MtyWqC.png)

```java
public boolean remove

주어진 원소가 이 컬렉션 안에 있다면 그 인스턴스를 하나 제거합니다.(선택적 동작)
더 정확하게 말하면, 이 컬렉션 안에 'Object.equals(o, e)가 참인 원소'e가 하나 이상 있다면 그중 하나를 제거합니다. 주어진 원소가 컬렉션 안에 있었다면 (즉 호출 결과 이 컬렉션이 변경 됐다면)true를 반환한다.

implementation Requirements: 이 메서드는 컬렉션을 순회하며 주어진 원소를 찾도록 구현되었습니다. 주어진 원소를 찾으면 반복자의 remove 메서드를 사용해 컬렉션에서 제거합니다. 이 컬렉션이 주어진 객체를 갖고 있으나 이 컬렉션의 iterator 메서드가 반환한 반복자가 remove 메서드를 구현하지 않았다면 UnsupportedOperationException을 던지니 주의하세요.
```

이 설명에 따르면 iterator 메서드를 재정의하면 remove 메서드의 동작에 영향을 줌을 확실히 알 수 있습니다.   iterator 메서드로 얻은 반복자의 동작이 remove 메서드이 동작에 주는 영향도 정확히 설명했습니다.

```
❗️ Item 18에서는 HashSet을 상속하여 add를 재정의한 것이 addAll에까지 영향을 준다는 사실을 알 수 없는데, 아주 대조적입니다.
```

이처럼 클래스를 안전하게 상속할 수 있도록 하려면(상속만 아니었다면 기술하지 않았어야 할 ) 내부 구현 방식을 설명해야만 합니다.


## 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

효율적인 하위 클래스를 어려움 없이 만들 수 있게 하려면 클래스 내부 동작 과정 중간에 끼어들 수 있는 훅을 잘 선별하여 `protected`메서드 형태로 공개해야할 수도 있습니다.


>아래 예시는 `java.util.AbstractList`의 `removeRange`메서드 입니다.
![](https://i.imgur.com/ujB1qtz.png)


- `removeRange`메서드를 제공하는 이유는 하위 클래스에서 부분리스트의 `clear`메서드를 고성능으로 만들기 쉽게 하기 위해서입니다. 
	- 만약 이 메서드가 없다면 하위 클래스에서 clear를 호출했을 때 제거할 원소의 제공에 비례해 성능이 느려지거나 부분리스트의 매커니즘을 새로 구현해야합니다. 



여기까지 보면 궁금증이 생긴다.  

#### ❓그렇다면 상속용 클래스를 설계할 때 어떤 메서드를 protected로 노출해야할지는 어떻게 결정해야할까요?

안타깝게도 만능은 없습니다.  
단지 심사숙고해서 잘 예측해본 다음, 실제 하위 클래스를 만들어 시험해보는 것이 최선입니다.   
`protected`메서드 하나하나가 내부 구현에 해당하므로 그 수는 가능한 적어야 합니다.

한편으로 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 합니다.

꼭 필요한 protected 멤버를 놓쳤다면 하위 클래스를 작성할 때 그 빈자리가 확연히 드러납니다. 거꾸로, 하위 클래스를 여러 개 만들 때까지 전혀 쓰이지 않는 protected 멤버는 사실 private이었어야 할 가능성이 큽니다.  



## 생성자는 오버라이드 가능한 메서드를 호출해서는 안 됩니다.

생성자가 오버라이드 가능한 메서드를 호출하면 하위 클래스에서 그 메서드를 오버라이드 했을 때 문제가 발생할 수 있기 때문입니다. 
(❗️private, final, static 메서드는 재정의가 불가하므로 생성자에서 호출해도 됩니다.)


## 클래스가 `Cloneable`이나 `Serializable`을 구현한다면 특별한 주의가 필요합니다. 

`clone`이나 `readObject` 메서드는 어버라이드 가능한 메서드를 직접적이거나 간접적으로 호출하면 안 됩니다.

