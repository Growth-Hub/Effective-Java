# 1️⃣9️⃣ Item 19 : 상속을 고려해 설계하고 문서화 하라. 그러지 않았다면 상속을 금지하라.

<br>

## 📌 목차
1. 상속 고려한 설계와 문서화
2. 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다. 
3. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook 잘 선별해 protected 메서드 형태로 공개해야 한다. 
4. 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스 만들어 검증해야 한다. 
5. 상속용 클래스의 생성자는 직간접적으로 재정의 기능 메서드 호출해서는 안된다. 
6. Cloneable & Serializable 구현한 클래스 상속할 수 있게 설계하는 것은 좋지 않은 생각이다. 
7. 일반 구체 클래스
8. 결론

<br>

## 📝 상속 고려한 설계와 문서화

상속을 `염두에 두지 않고 설계`했고 상속할 때의 `주의점도 문서화해놓지 않은` 외부 클래스를 상속할 때의 위험을 경고했다. 

외부 클래스는 프로그래머의 통제권 밖에 있어서 `언제 어떻게 변경될지 모르는 클래스`다. 

<br>

그러면 상속을 고려한 설계와 문서화란 정확히 무엇을 뜻할까?

***`상속을 고려한 설계를 하고 어떻게 문서화`*** 를 해야 하는지 보자. 

<br>

## 📂 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.

하위 클래스에서 상속하고 메서드를 재정의하면 어떤 일이 일어나는지 정확히 정리해 `문서로 남겨야 한다`. 

즉 상속용 클래스는 재정의 할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다. 

<br>

어떤 것을 문서화 해야 하는지 보자. 

- API로 공개된 메서드 안에서 `재정의 가능한 메서드 호출`하는 사실
- `어떤 순서`로 재정의 가능한 메서드 호출하는지
- 각각의 재정의 가능 메서드 호출 결과가 `이어지는 처리에 어떤 영향` 주는지
- 재정의 가능 메서드 호출할 수 있는 `모든 상황`

<br>

여기서 재정의 가능이란 public or protected 메서드 중 final이 아닌 모든 메서드를 말한다. 

상속용 클래스의 메서드들이기 때문에 하위 클래스에서 상속하면 상위 클래스의 public, protected 메서드를 다 오버라이딩 할 수 있다. 

<br>

### 🤷 Where?

이런 것들을 API로 `공개된 메서드의 API 설명`에 적어줘야 한다. 

이런 것들을 어디에 적는지 보자. 

API 문서의 메서드 설명 끝에서 종종 `Implementation Requirements`로 시작하는 절이 있다. 

이곳이 메서드의 내부 동작 방식을 설명하는 곳이다. 

<br>

### ❓ Why?

그렇다면 왜 이렇게 `재정의 가능한 메서드를 호출`할 수 있는 것을 알려줘야 할까?

왜냐하면 상위 클래스 Parent의 A 메서드에서 내부 메서드 B를 사용하는데 이 내부 메서드 B가 오버라이딩 가능하다. 

그러면 하위 클래스 Child에서 이 `내부 메서드 B를 오버라이딩` 하는데 정확히 재정의 하지 않고 자기 마음대로 재정의 했다. 

그리고 하위 클래스 Child에서 상위 클래스 Parent의 A 메서드를 호출하면 이 A 메서드에서는 하위 클래스 Child의 내부 메서드 C를 호출한다. 

그렇다면 내부 메서드 C를 정확히 재정의 하지 않았기 때문에 `상위 클래스` Parent의 A `메서드가 제대로 동작하지 않게 되는 문제점`이 생기는 것이다. 

따라서 내부 메서드가 어떻게 동작하는지 정확히 설명을 해줘야 하는 것이다. 

<br>

**Parent 클래스**

```java
public class Parent {

    public void A(){
        System.out.println("부모 클래스 메서드 사용");
        B();
    }

    public void B(){
        System.out.println("재정의 한 메서드 사용");
    }

}
```

**Child 클래스**

```java
public class Child extends Parent{

    @Override
    public void B() {
        System.out.println("!!@#$@!@$!@$!@");
    }
}

```

**Parent 클래스의 A 메서드 호출 시 결과**

```java
부모 클래스 메서드 사용
재정의 한 메서드 사용
```

**Child 클래스에서 A 메서드 호출 시 결과**

```java
부모 클래스 메서드 사용
!!@#$@!@$!@$!@
```

<br>

하위 클래스 Child에서 상위 클래스 Parent의 메서드를 사용할 때 Parent 클래스에서 정의한 것처럼 사용될 것이라고 예상을 한다. 

그런데 결과를 보면 `재정의를 정확하게 하지 않아서 이상한 동작`을 하게 되는 것이다. 

<br>

하지만 이렇게 API 문서에 내부 동작 방식 설명을 하는 것은 좋지 않다. 

좋은 API 문서는 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 한다. 

하지만 어쩔 수 없다. 

`상속이 캡슐화를 해치기 때문`에 일어나는 현실이다. 

클래스를 안전하게 상속할 수 있도록 하려면 `내부 구현 방식을 설명`해야만 한다. 

<br>

## 🏪 클래스의 내부 동작 과정 중간에 끼어들 수 있는 hook 잘 선별해 protected 메서드 형태로 공개해야 한다.

내부 메커니즘을 문서로 남기는 것만이 상속 위한 설계의 전부는 아니다. 

효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는` hook을 잘 선별해 protected 메서드` 형태로 공개해야 할 수도 있다.

<br>

### hook이란?

>후크(Hook) 는 추상 클래스에 들어있는, `아무 일도 하지 않거나 기본 행동을 정의하는 메소드`로, 서브 클래스에서 오버라이드 할 수 있다.
>
>기본 클래스에서 선언되지만 해당 동작을 사용자 지정하기 위해 하위 클래스에서 재정의되는 메서드다.
>
>이러한 메서드는 미리 정의된 `워크플로 또는 일련의 작업에 삽입`할 수 있는 사용자 지정 코드의 자리 표시자 역할을 한다. 
>
>즉 기본 코드를 변경할 필요 없이 코드 설계의 유연성을 높이고 코드 재사용을 촉진할 수 있다.
>
>'오버라이드 해서 전혀 다른 메소드로 만든다' 라는 면에서는 추상 메소드랑 크게 다를바 없어보인다.
>
>하지만 `추상메소드는 '강제적'` 이다.
>
>반드시 오버라이드 해야만 한다. 
>
>하지만 `후크메소드는 '선택적'` 이다. 
>
>더군다나 abstract 라는 키워드도 필요 없다

<br>

이런 예시로 java.util.AbstractList의 removeRange라는 메서드가 있다. 

이 메서드는 특정 구간의 원소를 리스트에서 제거하는 메서드다. 

List 구현체의 `최종 사용자는 removeRange 메서드에 관심이 없다`. 

그럼에도 이 메서드를 제공한 이유는 단지 하위 클래스에서 리스트의 일부에 대한 clear 메서드를 고성능으로 만들기 쉽게 하기 위해서다. 

clear 메서드에서 removerRange를 처음부터 끝 index까지 돌린다. 

removeRange 메서드가 없다면 하위 클래스에서 clear 메서드 호출하면 성능이 느려지거나 리스트의 일부에 대한 메커니즘을 밑바닥부터 새로 구현해야 했을 것이다. 

이렇듯 하위 클래스에서는 사용하지 않지만 `하위 클래스에서 사용하는 메서드에 hook으로 들어가 있는 메서드들을 protected로 제공`해야 한다는 의미다.

<br>

그렇다면 상속용 클래스 설계할 때 어떤 메서드를 protected로 노출해야 하는지 `어떻게 결정`하는가?

***`아쉽게도 정해진 것은 없다.`***

심사숙고해서 잘 예측해본 다음 실제 하위 클래스를 만들어 시험해보는 것이 최선이다. 

protected 메서드 하나하나가 내부 구현에 해당해서 그 수가 가능한 적어야 한다. 

한편으로는 너무 적게 노출해서 상속으로 얻는 이점마저 없애지 않도록 주의해야 한다. 

<br>

## 🔎 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스 만들어 검증해야 한다.

앞에서 상속용 클래스를 `시험해 봐야 한다`고 했다. 

이 상속용 클래스를 시험하는 방법은 `직접 하위 클래스를 만들어보는 것`이 유일하다. 

이런 검증에는 하위 클래스 `3개` 정도 만들어 보는 것이 적당하다고 한다. 

그리고 이 중 하나 이상은 제 3자가 작성해봐야 한다. 

<br>

널리 쓰일 클래스를 상속용으로 설계한다면 우리가 문서화한 내부 사용 패턴과 protected 메서드와 필드를 구현하면서 선택한 결정이 영원히 책임져야 함을 잘 인식해야 한다. 

이 결정들이 그 클래스의 성능과 기능에 영원한 족쇄가 될 수 있다. 

따라서 `상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증`해야 한다. 

<br>

## 📞 상속용 클래스의 생성자는 직간접적으로 재정의 기능 메서드 호출해서는 안된다.

상속을 허용하는 클래스가 지켜야 할 제약이 아직 몇 개 남았다. 

상속용 클래스의 `생성자는 직간접적으로 재정의 기능 메서드 호출해서는 안된다`. 

<br>

이 규칙을 어기면 프로그램이 오동작할 것이다. 

왜냐하면 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되기 때문이다. 

그래서 하위 클래스에서 재정의한 메서드가 `하위 클래스의 생성자보다 먼저 호출`이 된다. 

이때 그 재정의한 메서드가 하위 클래스의 생성자에서 초기화하는 값에 의존한다면 의도한대로 동작하지 않을 것이다. 

<br>

다음과 같이 메서드들이 진행이 되는 것이다. 

`상위 클래스 생성자 → 하위 클래스에서 재정의한 메서드 → 하위 클래스의 생성자`

하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자에서 초기화 해야 하는 필드를 예를 들어 사용한다면 무조건 에러가 날 것이다. 

<br>

## ❌ Cloneable & Serializable 구현한 클래스 상속할 수 있게 설계하는 것은 좋지 않은 생각이다.

Cloneable과 Serializable 인터페이스는 상속용 설계의 어려움을 한층 더해준다. 

둘 중 하나라도 구현한 클래스를 상속할 수 있게 설계하는 것은 좋지 않은 생각이다. 

<br>

왜 그런가 하면 `clone 메서드와 readObject 메서드는 생성자와 비슷한 효과`를 낸다. 

clone과 readObject 메서드 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다. 

clone 메서드는 하위 클래스의 clone 메서드가 복제본의 상태를 올바른 상태로 수정하기 전에 재정의한 메서드 호출한다. 

readObject 메서드의 경우 하위 클래스의 상태가 미처다 역직렬화되기 전에 재정의한 메서드부터 호출하게 된다. 

따라서 내부에서 재정의 가능 메서드 호출하면 문제가 생긴다. 

<br>

여기에 추가로 Serializable 구현한 상속용 클래스가 readResolve, writeReplace 메서드 갖는다면 이 메서드들은 private가 아닌 protected로 선언해야 한다고 한다. 

private로 선언한다면 하위 클래스에서 무시된다고 한다. 

<br>

## ⏺ 일반 구체 클래스

일반 구체 클래스들은 final도 아니고 상속용으로 설계되거나 문서화 되지도 않았다. 

누군가 이런 `일반 구체 클래스를 상속 받으면 문제`가 생길 수 있다. 

왜냐하면 일반 구체 클래스에 변화 생길 때마다 하위 클래스 오동작하게 만들 수 있기 때문이다. 

<br>

따라서 `상속용으로 설계하지 않은 클래스는 상속을 금지`하는 것이 좋은 방법이다. 

상속 금지하는 방법은 2가지가 있다. 

- final 클래스로 선언
- 모든 생성자를 private or package-private로 선언하고 public 정적 팩터리 생성

<br>

하지만 상속을 금지하는 것은 논란이 있고 사용하기 상당히 불편해진다. 

그래서 일반 구체 클래스에서 상속 꼭 허용해야겠다면 방법이 하나 있다. 

바로 클래스 내부에서는 `재정의 가능 메서드 사용하지 않게 만들고 이 사실을 문서로 남기라는 것`이다. 

이렇게 하면 메서드를 재정의해도 다른 메서드의 동작에 아무런 영향 주지 않는다. 

<br>

## ‼ 결론

상속용 클래스를 설계하기란 만만치 않다. 

클래스 `내부에서 스스로를 어떻게 사용하는지 모두 문서`로 남겨야 한다. 

그리고 문서화 한 것은 그 클래스가 쓰이는 한 `반드시 지켜야 한다`. 

그렇지 않으면 그 `내부 구현 방식을 믿고 활용하던 하위 클래스`를 오동작하게 만들 수 있다. 

다른 이가 효율 좋은 하위 클래스를 만들 수 있도록 일부 메서드를 protected로 제공해야 할 수도 있다. 

그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 `상속을 금지하는 편`이 나을 것이다. 

상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없게 만들면 된다. 

<br>

## 📍 references

- [hook 메서드 1](https://berom.tistory.com/226)
- [hook 메서드 2](https://mrtint.tistory.com/358)