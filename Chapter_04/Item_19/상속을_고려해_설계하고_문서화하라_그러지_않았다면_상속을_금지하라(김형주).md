책은 다음과 같이 강조하고 있다.

#### "상속용 클래스는 재정의 할 수 있는 메서드들은 내부적으로 어떻게 이용하는지 문서로 남겨야한다."

## 🌱 문서화 예시
<p align = "center">
<img width="700" alt="image" src="https://github.com/kim0527/Effective-Java/assets/143387515/89429551-ae9d-4228-b7f2-35e0cbaf5b10">
</p>

- AbstractCollection 인터페이스의 remove() 메서드이다.
- ```@implSpec```태그를 명시하고 내부 동작 방식을 설명해 놓은 것을 확인할 수 있다.

## 🤔 문서화...? 왜 필요할까?
- 클래스의 API로 공개된 메서드에서 또 다른 메서드를 호출할 수 있다.
- 프로그래머의 통제권 밖인 외부에서 해당 메서드를 재정의과정 속에서 어떻게 변경될지 모른다.
- 즉, 원래 설계된 의도와 다르게 설계될 수도 있다.

## ✅  어떤 내용을 문선화 해둬야 할까?

1. 어떤 순서로 호출하는지
2. 각 호출 결과가 이어지는 처리에 어떤 영향을 주는지
3. 메서드 내부 동작 방식

이처럼 원래 메서드 의도를 밝혀, 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야한다.

> 사실 "좋은 API문서란? 어떻게가 아닌 무엇을 하는지 설명해야 한다" 와 대조된다. 😥

> 상속이 캡슐화를 해치기 때문에 어쩔수 없다. 안전한 상속을 위해서는 내부 구현 방식을 자세히 설명할 수 밖에 없다.

## 👀 그렇다면 이제 문서화만 잘해두면 끝인가?
클래스의 내부 동작 과정 중간에 끼어들 수 있는 ```훅(hook)```을 잘 선별하여 protected 메서드 형태로 공개할지 고민해봐야 한다.

## 훅(hook)이란?
- 소프트웨어 구성 요소 간에 발생하는 함수 호출, 메시지, 이벤트 등을 중간에서 바꾸거나 가로채는 행위를 ```hooking```이라고 한다.
- 이때 이러한 간섭된 함수 호출, 이벤트 또는 메시지를 처리하는 코드를 ```hook```이라고 한다.

## 훅(hook)메서드 protected 예시
```java
//AbstractList의 removeRange()
protected void removeRange(int fromIndex, int toIndex) {
    ListIterator<E> it = listIterator(fromIndex);
    for (int i=0, n=toIndex-fromIndex; i<n; i++) {
        it.next();
        it.remove();
    }
}
public void clear() {
    removeRange(0, size());
}
```
예시로 AbstractList의 removeRange()가 있다.
- ```removeRange()```는 특정 인덱스 범위를 제거하는 메서드이다.
- 이를 하위클래스에서 직접 사용하는 일은 없어, 해당 메서드는 관심이 없다.
- 하지만 하위클래스에서 사용할 clear를 고성능으로 만들기 쉽게 하기 위해서 제공은 해야한다.

이처럼 하위 클래스에서 사용할 메서드에 hook으로 들어가있는 메서드는 ```protected```로 제공하는 것이 올바르다.

#### 🤷‍♂ 그렇다면 이처럼 protected로 노출해야 하는 메서드는 어떤 기준으로 결정할까?
- 아쉽게도 정확한 기준은 정해져 있지 않다.
- 심사숙고해서 잘 예측해본 다음, 직접 하위 클래스를 만들어보는 수 밖에 없다.
- 이후에 메서드가 쓰이는 안쓰이는지를 확인해보면서, protected를 정해주고 전혀 안쓰인다면 private도 고려해봐야 한다.

## 🧑‍💻 상속용 클래스 설계 시 주의사항

#### 1. 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야한다.
- 문서화 및 protected 메서드 등 선택한 결정이 그 클래스의 성능 과 기능에 영원한 족쇄가 될 수 있다.
- 그러니 배포 전, 하위 클래스를 통한 검증은 필수이다.

#### 2. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행된다.
- 만약 상위 클래스 생성자에 재정의한 메서드가 호출된다면, 메서드가 하위 클래스 생성자보다 먼저 호출되는 현상이 발생한다.

#### 3. Cloneable과 Serializable 인터페이스로 구현한 클래스를 상속할 수 있게 두는 것은 좋지 않다.
- 클래스를 확장하려는 프로그래머에게 엄청난 부담을 준다.

### 🥎 정리
상속용 클래스를 만든다면
- 클래스 내부가 어떻게 동작하는지 문서화 해야한다.
- 하위 클래스에서 메서드를 재정의 할때 문서화한 내용을 필수적으로 지켜야한다.
- protected, private 접근제한자도 고민해봐야 한다.
- 3가지 주의사항도 참고해야한다.

이처럼 상속용 클래스를 설계하는 것은 쉽지 않다.

그러니 확장해야할 이유가 명확하지 않다면, **상속을 금지하자.**
> 상속을 막는 2가지 방법 : 클래스 final 선언 or 생성자 private 선언

### 📝 Reference
[Java의 Hook Method](https://berom.tistory.com/226)

[Hooking](https://shuu.tistory.com/22)
