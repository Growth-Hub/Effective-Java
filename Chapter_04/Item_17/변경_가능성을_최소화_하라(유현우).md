# 변경 가능성을 최소화 하라
**가변 객체는 임의의 복잡한 상태에 놓일 수 있다. 웬만하면 불변 객체로 사용하자**

- 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않으면 가변 클래스를 믿고 사용하기 어렵다.

## 불변 객체

- 한번 초기화 되면 인스턴스 내부의 값을  수정할 수 없다.
- 객체가 생성된 시점의 상태를 파괴될 때까지 그대로 간직해야 한다.
- 자바 플랫폼에서는 String, wrapper 클래스, BigDecimal, BigInteger등이 있다.

## 클래스를 불변으로 만드는 방법

**1. 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.**

**2. 클래스를 확장할 수 없도록 한다.**

- 하위 클래스에서 부주의하게 객체의 상태를 변하게 만드는 사태를 막아준다.

**3. 모든 필드를 fianl로 선언한다.**

- 시스템이 강제하는 수단을 이용해 설계자의 의도를 명확히 드러내는 방법
    - 멀티 스레드 환경에서 안정성 보장

**4. 모든 필드를 private으로 선언한다.**

- 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아준다.

**5. 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.**

- 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
- getter로 필드를 그대로 반환하지말고 복사해서 반환하거나 `Collections.*unmodifiableXXX`* 이용하자

**인스턴스 자신은 수정하지 않고 새로운 Complex 인스턴스를 만들어 반환하는 것을 볼 수 있다.**

```java
public Complex plus(Complex c) {
		return new Complex(re + c.re, im + c.im);
}
```

- 메서드 이름이 add(동사) 대신 plus(전치사)를 사용한 이유는 해당 메서드가 객체의 값을 변경하지 않는다는 사실을 강조하려는 의도이다.

## 불변 객체의 장점

### 불변 객체는 스레드에 안전하다.

불변 객체는 값이 절대 변하지 않는다. 즉 어떤 스레드도 다른 스레드에 영향을 줄 수 없기 때문에  따로 동기화할 필요가 없이 안심하고 공유할 수 있다.

### **값이 절대 변하지 않는 특징 때문에 방어적 복사도 필요 없다. (clone 메서드나 복사 생성자 사용하지 말자)**

BigInteger 클래스는 내부에서 값의 부호와 크기를 따로 표현한다.

- negate 메서드는 크기가 같고 부호만 반대인 새로운 BigInteger를 생성하는데 배열이 가변인데도 불구하고 복사하지 않고 원본 인스턴스와 공유해도 상관이 없다. (수정될일이 없기 때문에)

### 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면 이점이 많다.

- Map(key), Set(value)으로 불변 객체가 사용할 때 안에 담긴 값이 바뀌지 않아 걱정하지 않아도 된다.

### 불변 객체는 그 자체로 실패 원자성을 제공한다.

- 상태가 절대 변하지 않으니 메서드에서 예외가 발생한 후에도 항상 불변 객체는 호출전과 동일한 상태를 가진다.

---

## 한번 만든 불변 객체 인스턴스를 최대한 재활용하자

- 가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수로 제공하는 것이다.
- <img width="905" alt="image" src="https://github.com/uhanuu/Effective-Java/assets/110734817/43e13767-c9e9-4cf8-878d-acd26eb21258">

- BigInteger 클래스에서 자주 사용하는 숫자들을 싱글톤 처럼 재사용 할 수 있도록 하고 있었다.

### 불변 클래스는 정적 팩터리를 통해서 자주 사용되는 인스턴스를 캐싱하여 같은 인스턴스 중복 생성을 막을 수 있다.

- 재사용으로 인해서 메모리 사용량과 가비지 컬렉션 비용을 줄일 수 있다.
- 생성자 대신 정적 팩터리를 만들어두면 클라이언트를 수정하지 않고도 필요에 따라 캐시 기능을 덧붙일 수 있다.

```java
@jdk.internal.ValueBased
public final class Boolean implements java.io.Serializable,
                                      Comparable<Boolean>, Constable
{
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);
							    ...
}
```
<img width="850" alt="image" src="https://github.com/uhanuu/Effective-Java/assets/110734817/b712bf8c-b723-4b31-955a-b073466733b7">


- 박싱된 기본 타입 클래스 전부와 BigInteger가 여기 속한다.

## 불변 객체의 단점

### 값이 다르면 반드시 독립된 객체로 만들어야 한다.

- 값의 가짓수가 많다면 객체를 만들 때 가짓수의 비례해서 시간과 공간을 잡아먹는다.

### 불변 객체가 만약 하위클래스가 존재할 수 있다면 주의해야 한다.

BigInteger, BigDecimal은 상속이 가능하다 따라서 하위 클래스에서 불변을 지키지 못하는 경우가 있을 수 있다.

```java
public static BigInteger safeInstance(BigInteger val) {
	return val.getClass() == BigInger.class ?
					val : new BigInteger(val.toByteArray());
}
```

- 신뢰할 수 없는 하위 클래스의 인스턴스라고 확인되면 이 인수들은 가변이라 가정하고 방어적 복사해 사용해야 한다.

---

### 성능을 위해서 계산 비용이 큰 값을 나중에 (처음 쓰일 때) 계산하여 final이 아닌 필드에 캐시해 놓기도 한다.

- 다시 요청하면 캐시해둔 값을 반환하여 계산 비용을 절감할 수 있다.
    - 순전히 이 객체가 불변이기 때문에 사용할 수 있는 방법이다. (몇 번을 계산해도 항상 같은 결과가 만들어지는 것이 보장되기 때문이다.)
    - 이 때 자원을 계속 가지고 있는게 아니라고 생각이 들면 `WeakHashMap` 사용할 수 있을거 같기도 하다.즉 라이프 사이클이 객체가 죽을 때 까지 이어져야 하는건지 고민하고 사용하면 되겠다.

### 직렬화할 때 주의할 점

- Serializable을 구현하는 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있을 때

`readObject`나 `readResolve` 메서드를 반드시 제공하거나, `ObjectOutputStream.writeUnshared`와 `ObjectInputStream.readUnshared` 메서드를 사용해야 한다.

- 플랫폼이 제공하는 기본 직렬화 방법이 충분하더라도 공격자가 이 클래스로부터 가변 인스턴스를 만들어낼 수 있기 때문이다.

### 정리

- Getter가 있다고 무조건 Setter를 만들지 말자
- 클래스는 꼭 필요한 경우가 아니라면 불변이어야 한다.
    - 불변은 장점이 많고 단점은 특정 상황에서의 잠재적 성능 저하뿐이다.
- PhoneNumber와 Complex같은 단순한 값 객체는 항상 불변으로 만들자
- String과 BigInteger처럼 무거운 값 객체도 불변으로 만들 수 있는지 고심해야 한다.
    - 성능 이슈가 있다면 (아이템 67) 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자
- 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자.
    - 변경해야 할 필드를 뺀 나머지는 모두 final로 선언하자
- 다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.
- 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.
    - 클라이언트에서 완벽한 초기화를 못 시켜줄 수 있기 때문에 그 어떤 초기화 메서드도 public으로 제공하지 말자
    - 객체를 재활용할 목적으로 상태를 다시 초기화하는 메서드도 안된다. 복잡성만 커지고 성능 이점은 거의 없음
