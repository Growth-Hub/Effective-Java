# 🚀 Item 17 변경 가능성을 최소화하라

 
**❓불변 클래스란**     

불변 클래스란 간단히 말해 그 인스턴스의 내부 값을 수정할 수 없는 클래스를 뜻합니다.
불변 인스턴스에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않습니다.


개발자들은 왜 불변클래스를 사용하는 걸까요?   

대표적인 이유로는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며 오류가 생길 가능성이 적어 안정성이 보장되기 때문입니다.   

그럼 이런 가변 클래스를 어떻게 만들고 구체적으로 어떠한 장점들이 있는지 알아봅시다.     

먼저 클래스를 불변으로 만들려면 다음 다섯 가지 규칙을 따르면 됩니다.

### 1️⃣ 객체의 상태를 변경하는 메서드(변경자)를 제공하지 않는다.

```java
public class PhoneNumber {

	private short areaCode, prefix, lineNum;

	setAreaCode(short areaCode) {
		this.areaCode = areaCode;
	}

}
```

위 코드 처럼  set 메서드를 제공하지 않아야 합니다.

### 2️⃣ 클래스를 확장할 수 없도록 한다.

하위 클래스에서 부주의하게 혹은 나쁜 의도로 객체의 상태를 변하게 만드는 사태를 막아줍니다.


> 간단한 방법으로는 클래스를 final로 선언하면 됩니다.
```java
public final class PhoneNumber {

	private short areaCode, prefix, lineNum;

	// ...

}
```

### 3️⃣ 모든 필드를 final로 선언한다.


```java
public final class PhoneNumber {

	private final short areaCode, prefix, lineNum;

	// ...

}
```

### 4️⃣ 모든 필드를 private으로 선언한다.  

필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일을 막아주비다.
물론 public final로만 선언해도 불변 객체가 되지만, 이렇게하면 다음 릴리스에서 내부 표현을 바꾸지 못하므로 권하지는 않습니다.

### 5️⃣ 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.

클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 합니다.  


이 규칙에 따라 불변 객체를 만들면 무엇이 좋을까요?


## 🚀 불변 객체의 이점


### 1. 불변 객체의 단순성 (p 107)

불변 객체는 생성된 시점의 상태를 파괴될 때까지 그대로 간직합니다.  
- 모든 생성자가 클래스 불변식(class invariant)을 보장한다면 그 클래스를 사용하는 프로그래머가 다른 노력을 들이지 않더라도 영원히 불변으로 남습니다.  
- 반면 가변 객체는 임의의 복잡한 상태에 놓일 수 있습니다.
	- 변경자 메서드가 일으키는 상태 전이를 정밀하게 문서로 남겨놓지 않은 가변 클래스는 믿고 사용하기 어려울 수 있습니다.  

### 2. 동기화할 필요성 ❌  -> 공유 가능 -> 재활용 가능(p 108)

불변 객체는 여러 스레드가 동시에 사용해도 절대 훼손되지 않습니다.그렇기에 따로 동기화할 필요 없습니다. 
불변 객체에 대해서는 그 어떤 스레드도 다른 스레드에 영향을 줄 수 없으니 불변 객체는 안심하고 공유할 수 있습니다. 따라서 불변 클래스라면 한번 만든 인스턴스를 최대한 재활용하면 좋습니다.  

가장 쉬운 재활용 방법은 자주 쓰이는 값들을 상수(public static final)로 제공하는 것입니다.  
>예를들면 Complex 클래스는 다음 상수들을 제공할 수 있습니다.
```java
public static final Complex ZERO = new Complex(0, 0);
public static final Complex One = new Complex(1, 0);
public static final Complex I = new Complex(0, 1);
```

### 3. 방어적 복사 ❌

불변 객체를 자유롭게 공유할 수 잇다는 점은 방어적 복사(Item 50)도 필요 없다는 결론으로 자연스럽게 이어집니다. 아무리 복사해봐야 원본과 똑같으니 복사 자체가 의미가 없습니다.  

String 클래스의 복사 생성자는 이 사실을 잘 이해하지 못한 자바 초창기 때 만들어진 것으로 되도록 사용하지 말아야 합니다.(Itme 6)

### 4. 불변 객체끼리는 내부 데이터를 공유할 수 있다.

예컨대 `BigInteger` 클래스를 살펴보면 부호(sign)와 크기(magnitude)를 따로 표현합니다. 부호에는 int 변수를, 크기(절대값)에는 int 배열을 사용합니다.  크기는 같고 부호만 반대로 표현하는 `negate` 메서드를 보면 새로운 BigInteger를 생성하는데, 아래와 같이 가변인 배열을 복사하지 않고 원본 인스턴스와 공유하여 사용합니다. 그 결과 새로 만든 BigInteger 인스턴스도 원본 인스턴스가 가리키는 내부 배열을 그대로 가리킵니다.

```java
public class BigInteger extends Number implements Comparable<BigInteger> {
    final int signum;//부호
    final int[] mag;//크기(절댓값)

    // ...코드 생략

    public BigInteger negate() {
        return new BigInteger(this.mag, -this.signum);
    }
}
```

### 5. 객체를 만들 때 다른 불변 객체들을 구성요소로 사용하면서오는 이점

값이 바뀌지 않는 구성요소들로 이뤄진 객체라면 그 구조가 아무리 복잡하더라도 불변식을 유지하기 훨씬 수월합니다. 좋은 예로, 불변 객체는 Map의 키와 집합(Set)의 원소로 쓰기에 안성맞춤입니다. Map이나 집합은 안에 담긴 값이 바뀌면 불변식이 허물어지는데, 불변 객체를 사용하면 그런 걱정은 하지 않아도 됩니다.  

### 6. 실패 원자성 제공

불변 객체는 그 자체로 실패 원자성을 제공합니다.(Item 76)  상태가 절대 변하지 않으니 잠깐이라도 불일치 상태에 빠질 가능성이 없습니다.

>❓실패 원자성
```
📌 실패 원자성의 중요성

실패 원자성은 예기치 않은 상황에서도 시스템의 안정성을 보장하는 데 필수적입니다.
만약 메소드 호출이 실패했을 때 객체가 일관성 없는 상태에 빠진다면, 그로 인해 발생하는 오류는 디버깅하기 매우 어려워질 수 있습니다.
더 나아가, 이러한 일관성 없는 상태는 보안 취약점으로 이어질 수도 있습니다.

📌 실패 원자성을 달성하는 방법

1. 불변 객체 사용: 객체를 불변으로 만들면, 그 상태가 절대로 변하지 않기 때문에 실패 원자성을 자연스럽게 달성할 수 있습니다.
    
2. 상태 변화를 마지막에 수행: 메소드 내에서 필요한 모든 계산을 수행한 후에, 객체의 상태를 변경합니다.
                        즉, 어떤 예외도 발생하지 않았을 때만 실제 객체의 상태를 변경하는 방식으로 구현합니다.
    
3. 임시 복사본에서 작업 수행: 작업을 객체의 임시 복사본에서 수행한 다음, 작업이 성공적으로 완료되면 원본 객체에 변경 사항을 적용합니다.
                        이 방법은 객체의 상태를 변경하는 작업이 실패했을 때 원본 객체를 보호할 수 있습니다.
    
4. 예외 조건을 사전에 체크: 메소드 실행 전에 모든 가능한 실패 조건을 체크하여, 메소드가 실행되기 전에 예외를 발생시키는 것입니다.
                       이렇게 하면 메소드가 실행 도중 실패해도 객체의 상태가 변경되지 않습니다.
   
📌 예시

예를 들어, 컬렉션에 요소를 추가하는 메소드를 구현할 때, 메소드 내부에서 먼저 추가하려는 요소의 유효성 검사를 수행합니다. 이후에만 실제로 컬렉션에 요소를 추가합니다.
만약 유효성 검사에서 실패한다면, 메소드는 예외를 던지고 컬렉션은 변경되지 않습니다. 이는 실패 원자성을 보장하는 한 예시입니다.

실패 원자성은 프로그램의 견고함을 높이는 중요한 원칙 중 하나입니다.
이를 통해 개발자는 예기치 않은 실패로부터 프로그램의 일관성을 보호하고, 오류를 더 쉽게 추적하고 수정할 수 있습니다.
```
