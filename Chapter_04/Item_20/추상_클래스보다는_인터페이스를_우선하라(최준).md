# 2️⃣0️⃣ Item 20 :  추상 클래스보다는 인터페이스를 우선하라

<br>

## 📌 목차
1. 인터페이스 VS 추상 클래스
2. 인터페이스 장점
3. 추상 메서드 단점
4. 인터페이스 단점
5. 추상 골격 구현 클래스
6. 추상 골격 구현 클래스 작성
7. 결론

<br>

## 🆚 인터페이스 VS 추상 클래스

자바가 제공하는 `다중 구현 메커니즘`은 아래와 같이 2가지가 있다. 

- 인터페이스
- 추상 메서드

<br>

두 메커니즘 모두 `인스턴스 메서드를 구현 형태`로 제공할 수 있다. (인터페이스는 default 메서드)

<br>

둘의 가장 큰 차이가 있는데 `차이점`을 보자. 

- `추상 클래스`
    - 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다.

- `인터페이스`
    - 인터페이스가 선언한 메서드를 모두 정의하고 일반 규약 잘 지킨 클래스라면 다른 어떤 클래스를 상속했든 같은 타입으로 취급된다.

<br>

자바는 단일 상속만 지원하니 `추상 클래스 방식`은 새로운 타입을 정의하는데 커다란 제약 안게 된다. 

그렇기 때문에 이번 item에서 `추상 클래스보다는 인터페이스를 우선`하라고 하는 것이다. 

그렇다면 인터페이스는 어떤 장점이 있고 추상 클래스는 어떤 문제가 있는지 알아보자. 

<br>

## 👍 인터페이스 장점

인터페이스의 장점은 다음과 같다. 

- 기존 클래스에서도 손쉽게 `새로운 인터페이스를 구현해 넣을 수 있다`.
    - 인터페이스가 요구하는 메서드 추가하고 implements 구문한 추가하면 딘다.

- 인터페이스는`mixin 정의에 안성맞춤`이다.
    - 대상 타입의 주된 기능에 선택적 기능을 혼합 (mixed in)하기 쉽다.

- 인터페이스로는 `계층구조가 없는` 타입 프레임워크를 만들 수 있다.
    - 타입을 계층적으로 정의하면 수많은 개념 구조적으로 잘 표현할 수 있지만 현실에는 계층을 엄격히 구분하기 어려운 개념도 있다.

- `wrapper 클래스와 함께 사용`하면 인터페이스는 기능을 향상 시키는 안전하고 강력한 수단이 된다.

<br>

## 👎 추상 메서드 단점

추상 메서드의 단점은 다음과 같다. 

인터페이스의 장점에 반대된다고 생각하면 된다. 

<br>

- 기존 클래스 위에 `새로운 추상 메서드 끼워 넣기 어렵다`.
    - 두 클래스가 같은 추상 클래스 확장하려면 그 추상 클래스는 계층 구조상 두 클래스의 공통 조상이어야 한다.
    - 이렇게 하면 클래스 계층 구조에 큰 혼란 일으킨다.

- 추상 클래스로는 `mixin을 정의할 수 없다`.
    - 기존 클래스에 덧씌울 수 없기 때문이다.
    - 클래스는 두 부모 섬길 수 없고 클래스 계층 구조에 mixin 삽입할 위치가 없다.

- 추상클래스로 계층 구조로 표현하기 어려운 개념 만들면 `조합 폭발` 일어난다.
    - 여러 속성을 조합하는 클래스를 추상 클래스로 만들면 가능한 조합 전부를 각각의 클래스로 정의한 고도비만 계층 구조가 만들어진다.
    - 이런 것을 조합 폭발 현상이라고 부른다.

- 상속해서 만든 클래스는 `wrapper 클래스보다 활용도가 떨어지고 깨지기 쉽다`.
    - 타입을 추상 클래스로 정의하면 그 타입에 기능 추가하는 방법은 상속 뿐이다.

<br>

## 👎 인터페이스 단점

하지만 인터페이스의 `단점`도 있다. 

- `Object 메서드`를 default 메서드로 제공해서는 안된다.

- 인터페이스는 `인스턴스 필드 가질 수 없다`.

- `public 아닌 정적 멤버` 가질 수 없다. (private 정적 메서드 제외)

- `우리가 만들지 않은 인터페이스`에는 default 메서드 추가할 수 없다.

<br>

## 🦴 추상 골격 구현 클래스

이렇게 인터페이스와 추상 클래스에 장점, 단점이 다 존재하기 때문에 인터페이스와 추상 클래스의 장점을 모두 취하는 방법이 있다. 

바로 `인터페이스와 추상 골격 구현 클래스를 함께 제공`하는 것이다. 

<br>

>추상 골격 구현 클래스는 다른 말로 Abstract interface라고 불린다. 
>
>추상 골격 구현 클래스는 `interface의 장점과 abstract class의 장점을 혼합한 디자인 패턴`이다.
>
>추상 골격 구현 클래스는 위임방식을 사용해서 구현체가 상속(extends)가 아닌 구현(implements)의 방식으로 속성을 물려받도록 한다. 
>
>이 때 구현이지만 추상클래스를 상속받는 것과 같은 효과를 볼 수 있다.

<br>

어떻게 하는 것인가 하면 다음과 같이 하면 된다. 

- 인터페이스는 타입을 정의하고 필요하면 default 메서드 몇 개 도 함께 제공
- 추상 클래스인 골격 구현 클래스는 인터페이스의 default 메서드 아닌 나머지 메서드들까지 구현

<br>

이렇게 하고 단순히 추상 클래스인 골격 구현 클래스를 확장해서 하위 클래스 만들면 `인터페이스 구현하는데 필요한 일이 대부분 완료`된다. 

이것이 템플릿 메서드 패턴이다. 

<br>

**인터페이스**

```java
public interface Machine{

		void start();
		void stop();
		
		default void move(){
				System.out.println("move left");
		}
}
```

**추상 골격 구현 클래스**

```java
abstract class AbstractMachine implements Machine{
		
		@Override
		void start(){
				System.out.println("start");
		}
		
		@Override
		void stop(){
			System.out.println("stop");
		}

}
```

<br>

제대로 설계 했다면 골격 구현은 독립된 추상 클래스든 default 메서드로 이뤄진 인터페이스든 그 인터페이스로 나름의 구현을 만들려는 프로그래머의 일을 상당히 덜어준다. 

<br>

아래 예시는 int 배열을 List로 만들어서 반환하는 메서드인데 여기서 골격 구현 클래스를 활용해 쉽게 메서드를 구현한 것이다. 

```java
    static List<Integer> intArrayAsList(int[] a) {
        Objects.requireNonNull(a);

        // 다이아몬드 연산자를 이렇게 사용하는 건 자바 9부터 가능하다.
        // 더 낮은 버전을 사용한다면 <Integer>로 수정하자.
        return new AbstractList<>() {
            @Override public Integer get(int i) {
                return a[i];  // 오토박싱(아이템 6)
            }

            @Override public Integer set(int i, Integer val) {
                int oldVal = a[i];
                a[i] = val;     // 오토언박싱
                return oldVal;  // 오토박싱
            }

            @Override public int size() {
                return a.length;
            }
        };
    }
```

<br>

AbstractList라는 추상 골격 구현 클래스를 사용했다. 

이 추상 골격 클래스의 대부분의 메서드를 받아오고 (골격을 받아온 것이다) 이 메서드에 필요한 부분만 오버라이딩해서 재정의 하는 것을 볼 수 있다. 

<br>

## 📝 추상 골격 구현 클래스 작성

관례상 인터페이스 이름이 Interface라면 그 `골격 구현 클래스의 이름은 AbstractInterface`로 짓는다. 

어쩌면 `Skeletalnterface`로 하는 것이 더 적절했을지도 모르지만, 이미 Abstract를 접두어로 쓰는 형태가 확고히 자리 잡았다. 

<br>

골격 구현 클래스 작성은 조금 지루하지만 상대적으로 쉽다. 

1. 인터페이스를 잘 살펴 `다른 메서드들의 구현에 사용되는 기반 메서드들을 선정`한다. 
    1. 이 기반 메서드들은 **골격 구현에서는 추상 메서드**가 될 것이다. 

2. 기반 메서드들을 사용해 `직접 구현할 수 있는 메서드를 모두 default 메서드`로 제공한다. 
    1. equals, hashCode 같은 **Object의 메서드**는 default 메서드로 제공하면 안된다.
    2. 인터페이스의 메서드 모두가 기반 메서드, default 메서드가 되면 골격 구현 클래스 별도로 만들 이유는 없다.

3. 기반 메서드나 default 메서드로 `만들지 못한 메서드가 남아 있다면` 이 인터페이스를 구현하는 골격 구현 클래스를 하나 만들어 남은 메서드들을 작성해 넣는다. 
    1. 골격 구현 클래스에는 필요하면 public 아닌 필드와 메서드 추가해도 된다. 

<br>

`골격 구현은 기본적으로 상속해서 사용하는 것을 가정하므로 item 19에서 이야기한 설계 및 문서화 지침을 모두 따라야 한다`. 

인터페이스에 정의한 default 메서드든 별도의 추상 클래스든, 골격 구현 클래스는 반드시 그 동작 방식을 잘 정리해서 문서로 남겨야 한다. 

<br>

## ‼ 결론

일반적으로 `다중 구현용 타입으로는 인터페이스가 가장 적합`하다. 

복잡한 인터페이스라면 구현하는 수고를 덜어주는 `골격 구현을 함께 제공하는 방법을 꼭 고려`해보자. 

골격 구현은 가능한 최대한 인터페이스의 default 메서드로 제공하여 그 인터페이스를 구현한 모든 곳에서 활용하도록 하는 것이 좋다. 

가능한 최대한이라고 한 이유는 인터페이스에 걸려 있는 구현상의 제약 때문에 골격 구현을 추상 클래스로 제공하는 경우가 더 흔하기 때문이다. 

<br>

## 📍 references

- [추상 골격 구현 클래스](https://velog.io/@kms8571/%ED%8F%AC%EC%8A%A4%ED%8C%85-%EC%8A%A4%ED%84%B0%EB%94%94-JAVA%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-composition-and-skeletal-implementation)