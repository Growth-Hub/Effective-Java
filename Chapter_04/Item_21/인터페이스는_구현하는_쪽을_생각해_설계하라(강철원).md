# 🚀 Item 21 인터페이스는 구현하는 쪽을 생각해 설계하라

⭐️ 인터페이스의 중요성

인터페이스는 자바의 핵심 기능 중 하나로, 다형성을 구현하는 데 필수적입니다. 인터페이스를 통해 사용자는 다양한 구현체를 같은 방법으로 다룰 수 있습니다. 하지만, 인터페이스를 설계할 때는 이를 사용할 개발자의 입장에서 충분히 고민해야 합니다. 잘못 설계된 인터페이스는 개발자에게 혼란을 주고, 코드의 유지보수성을 떨어트릴 수 있습니다.


## 📌 인터페이스 설계의 원칙

인터페이스를 설계할 때는 다음과 같은 원칙을 따르는 것이 좋습니다:

1. **명확하고 간결하게**: 인터페이스는 사용자가 쉽게 이해하고 사용할 수 있도록 명확하고 간결해야 합니다.
2. **확장성을 고려하여**: 시간이 지나도 인터페이스를 쉽게 확장할 수 있도록 설계해야 합니다.
3. **디폴트 메서드 사용에 주의**: 자바 8부터 인터페이스에 디폴트 메서드를 추가할 수 있게 되었습니다. 이는 확장성을 높여주지만, 신중하게 사용해야 합니다.

자바 8전에는 기존 구현체를 깨드리지 않고는 인터페이스에 메서드를 추가할 방법이 없었습니다. 
 - 인터페이스에 메서드를 추가하면 보통은 컴파일 오류가 나는데, 추가된 메서드가 우연히 기존 구현체에 이미 존재할 가능성은 아주 낮기 때문입니다.
 
자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만 위험이 완전히 사라진 것은 아닙니다. 

**❓어떤 위험이 있을까?**

디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 되므로 모든 기존 구현체들과 매끄럽게 연동되리라는 보장을 할 수 없습니다.


>자바 8의 Collection 인터페이스에 추가된 디폴트 메서드
```java
default boolean removeIf(Predicate<? super E> filter) {
  Objects.requireNonNull(filter);
  boolean result = false;
  for(Iterator<E> it = iterator(); it.hasNext();) {
    if(filter.test(it.next())) {
      it.remove();
      result = true;
    }
  }

  return result;
}


```

인자로 Predicate를 받아 true를 반환하는 모든 원소를 제거합니다.

아파치에서 제공하는 `org.apache.commons.collections4.collection.SynchronizedCollection`은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다. 모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 **래퍼 클래스**입니다.

아파치의 `SynchronizedCollection`은 removeIf를 재정의하고 있지 않습니다. 이 클래스를 자바 8과 함께 사용한다면 디폴트 메서드인 removeIf의 디폴트 구현을 물려받게 되며, 모든 메서드에 대한 호출을 알아서 동기화해주지 못합니다. removeIf의 구현은 동기화나 락 객체에 대해 아무것도 모르고 있기 때문입니다.

따라서 SynchronizedCollection 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf를 호출하면 `ConcurrentModificationException`이 발생합니다. 디폴트 메서드는 `컴파일에 성공한다고 해도 기존 구현체에 런타임 오류를 일으킬 수 있는 것이다`.
## 디폴트 메서드를 추가해야할 때

기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야만 합니다. 추가할 때 기존 구현체들과 충돌하지 않을지도 고려해야합니다.

반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해줍니다.

그렇다고 인터페이스 설계 시 아무 고민 없이 디폴트 메서드를 추가하라는 것은 아닙니다. 인터페이스 설계에는 여전히 세심한 주의가 필요하며 릴리즈 이전에 반드시 꼼꼼한 테스트를 거쳐야 만 합니다.
