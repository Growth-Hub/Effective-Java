# 2️⃣1️⃣ Item 21 : 인터페이스는 구현하는 쪽을 생각해 설계하라

<br>

## 📌 목차
1. 인터페이스에 메서드 추가 방법
2. Default 메서드란?
3. default 메서드 문제점 
4. default 메서드 해결책
5. default 메서드 주의점

<br>

## ➕ 인터페이스에 메서드 추가 방법

자바 8 이전에는 기존 구현체를 깨뜨리지 않고는 `인터페이스에 메서드를 추가할 방법이 없었다`. 

<br>

인터페이스에 메서드를 추가하면 보통은 컴파일 오류가 난다. 

왜냐하면 인터페이스를 구현한 구현 클래스에서는 `반드시 인터페이스의 메서드를 오버라이딩 해야 하기 때문`이다. 

<br>

자바 8에 와서 기존 인터페이스에 메서드 추가할 수 있게 `default 메서드 소개`했다. 

하지만 이것이 생겼어도 위험이 완전히 사라진 것은 아니다. 

그리고 모든 기존 구현체들과 매끄럽게 연동되리라는 보장도 없다. 

<br>

왜냐하면 자바 7까지의 세상에서는 모든 클래스가 “현재 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다”고 가정하고 작성 되었기 때문이다. 

default 메서드는 구현 클래스에 대해 `아무것도 모른 채 합의 없이 무작정 ‘삽입’`될 뿐이다. 

<br>

## ❓ Default 메서드란?

인터페이스는 기능에 대한 선언만 가능하기 때문에, 실제 코드를 구현한 로직은 포함될 수 없다.

하지만 default 메서드는 이런 규칙을 깬 것이다. 

인터페이스에서 `메서드 앞에 default 키워드를 넣으면 인터페이스 내부에서도 로직이 포함된 메서드 선언`할 수 있다. 

```java
interface MyInterface { 
    default void printHello() { 
    	System.out.println("Hello World"); 
    } 
}
```

<br>

default 메서드가 등장한 이유에 대해서 알아보자. 

`인터페이스를 보완하는 과정에서 추가적으로 혹은 필수적으로 구현해야 하는 메서드가 생긴 것`이다. 

이때 그냥 인터페이스에 메서드 추가하면 인터페이스를 구현한 모든 클래스에서 추가한 메서드를 다 오버라이딩 해야 한다. 

이것은 매우 귀찮은 일이다. 

<br>

그리고 이렇게 하면 객체 지향 설계 5대 원칙인 `OCP도 어기게 되는 것`이다. 

OCP는 ‘소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다’ 이다.

왜 어기게 된 것인가 하면 기능 ‘확장’을 위해 구현 클래스의 기존 코드를 ‘변경’해야 하기 때문이다. 

추가된 메서드를 사용하지 않아도 우선 구현을 해 놔야 한다. 

<br>

이런 것을 해결하기 위해 default 메서드가 등장했다. 

구현 클래스에서 이 default 메서드를 `오버라이딩 하지 않아도 오류가 나지 않는다`. 

오버라이딩하지 않았다면 `인터페이스에 있는 default 메서드의 로직이 동작`한다. 

그리고 이 default 메서드는 구현 클래스에서 오버라이딩해서 재정의 할 수도 있다. 

<br>

## ❗ default 메서드 문제점

자바 8에서는 핵심 컬렉션 인터페이스들에 다수의 default 메서드가 추가되었다. 

주로 람다를 활용하기 위해서다. 

자바 라이브러리의 default 메서드는 코드 품질이 높고 범용적이라 대부분 상황에서 잘 작동한다. 

하지만 생각할 수 있는 `모든 상황에서 불변식을 해치지 않는 default 메서드를 작성하기란 어려운 법`이다. 

<br>

예시로 자바 8의 Collection 인터페이스에 추가된 removeIf 메서드가 있다. 

```java
    default boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        boolean removed = false;
        final Iterator<E> each = iterator();
        while (each.hasNext()) {
            if (filter.test(each.next())) {
                each.remove();
                removed = true;
            }
        }
        return removed;
    }
```

<br>

이 코드는 범용적으로 잘 구현되었지만 그렇다고 해서 모든 Collection 구현체랑 잘 어울리는 것은 아니다. 

잘 어울리지 않는 구현체의 예시로는 org.apache.commons.collections4.collection.SynchronizedCollection 클래스가 있다. 

이 클래스는 아파미 커먼즈 라이브러리이다. 

이 클래스는 클라이언트가 제공한 객체로 락을 거는 능력 추가로 제공한다. 

`모든 메서드에서 주어진 락 객체로 동기화한 후 내부 컬렉션 객체에 기능을 위임하는 wrapper 클래스`다. 

<br>

이 클래스는 활발히 관리되고 있지만 이 책을 쓰는 시점엔 removeIf 메서드를 재정의하지 않고 있다. 

이 클래스는 Collection 인터페이스를 구현한 구현 클래스다. 

따라서 자바 8과 사용하면 removeIf의 default 구현을 받게 된다. 

이렇게 하면 `모든 메서드 호출을 알아서 동기화 해주지 못한다`. 

Collection 인터페이스의 `removeIf 메서드는 동기화에 관해 아무것도 모르기 때문`이다. 

따라서 SynchronizedCollection 객체를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf 메서드 호출하면 예외 발생하거나 예상 못한 결과 발생할 수 있다. 

<br>

## 🔑 default 메서드 해결책

자바 플랫폼 라이브러리에서도 이런 문제 예방하기 위해 조치를 취했다. 

- 구현 클래스에서 인터페이스의 default 메서드 재정의 하게 함
- 다른 메서드에서는 default 메서드 호출하기 전에 필요한 작업 수행하도록 함

<br>

Collections.synchronizedCollection의 `클래스들은 removeIf를 재정의` 했다. 

그리고 이 removeIf 메서드를 호출하는 다른 메서드들은 default 구현을 호출하기 전에 동기화 하도록 했다. 

<br>

하지만 자바 플랫폼에 속하지 않은 제 3의 기존 컬렉션 구현체들은 이런 언어 차원의 인터페이스 변화에 맞춰 수정될 기회가 없었다. 

그리고 `그중 일부는 여전히 수정되지 않고 있다`. 

<br>

## ⚠ default 메서드 주의점

default 메서드를 사용할 때 `주의할 점`이 있다. 

1. default 메서드는 컴파일에 성공해도 `기존 구현체에 런타임 오류` 일으킬 수 있다. 

2. 기존 인터페이스에 default 메서드로 `새 메서드 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다`. 

3. default 메서드는 인터페이스로부터 `메서드 제거하거나 기존 메서드 시그니처 수정 용도 아님을 명심`해야 한다. 

4. default 메서드 있어도 인터페이스 설계할 때는 여전히 세심한 주의 기울여야 한다. 

<br>

### 1️⃣ 1번 주의점

default 메서드는 컴파일에 성공해도 기존 구현체에 런타임 오류 일으킬 수 있다. 

`흔한 일은 아니지만, 일어나지 않으리라는 보장도 없다`. 

자바 8은 Collection 인터페이스에 꽤 많은 default 메서드를 추가했다. 

그 결과 기존에 짜여진 많은 자바 코드가 영향 받았다고 한다. 

<br>

### 2️⃣ 2번 주의점

기존 인터페이스에 default 메서드로 새 메서드 추가하는 일은 꼭 필요한 경우 아니라면 피해야 한다. 

추가하려는 default 메서드가 `기존 구현체들과 충돌하지는 않을지` 심사숙고도 해야 한다. 

반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는데 default 메서드는 아주 유용한 수단이다. 

그리고 default 메서드는 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다고 한다. 

<br>

### 3️⃣ 3번 주의점

default 메서드는 인터페이스로부터 메서드 제거하거나 기존 메서드 시그니처 수정 용도 아님을 명심해야 한다. 

이런 형태로 인터페이스를 변경하면 `반드시 기존 클라이언트를 망가뜨리게 된다`. 

<br>

### 4️⃣ 4번 주의점

default 메서드 있어도 `인터페이스 설계할 때는 여전히 세심한 주의 기울여야 한다`. 

default 메서드로 기존 인터페이스에 새로운 메서드 추가하면 커다란 위험도 딸려온다. 

인터페이스 잘못 설계하면 인터페이스 사용하는 사용자, API 모두 큰 일이 날 수 있다. 

<br>

따라서 새로운 인터페이스라면 `릴리스 전에 반드시 테스트`를 거쳐야 한다. 

인터페이스를 구현한 구현 클래스를 많은 개발자들이 여러 방법으로 구현할 것이니 우리도 서로 다른 방법으로 `최소 3가지 구현 클래스`를 구현해봐야 한다. 

그리고 각 인터페이스의 인스턴스를 다양한 작업에 활용하는 클라이언트도 여러 개 만들어봐야 한다. 

<br>

이렇게 새 인터페이스가 의도한 용도에 잘 부합하는지 확인하는 길은 험난하다. 

하지만 이런 작업 거치면 인터페이스 `릴리스 하기 전에 바로 잡을 수 있을 때 결함 찾을 수 있다`. 

인터페이스 릴리스한 후라도 결함 수정하는게 가능한 경우도 있겠지만 절대 그 가능성에 기대서는 안된다. 

<br>

## 📍 references

- [default 메서드 1](https://siyoon210.tistory.com/95)
- [default 메서드 2](https://velog.io/@heoseungyeon/%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A9%94%EC%84%9C%EB%93%9CDefault-Method)