# 3️⃣2️⃣ Item 32 : 제네릭과 가변인수를 함께 쓸 때는 신중하라

<br>

## 📌 목차
1. 가변인수
2. 제네릭과 가변인수 문제점
3. 제네릭과 가변인수 문제점 이유
4. 제네릭과 가변인수 허용 이유
5. 제네릭과 가변인수 사용 시 경고 숨기는 법
6. 경고 숨기기 위한 메서드 안전한지 확인하는 법
7. 제네릭과 가변인수 사용 시 주의점
8. @SafeVargs외 다른 방법 
9. 결론

<br>

## 🗄 가변인수

가변 인수(varargs)란, `매개변수로 들어오는 값의 개수와 상관 없이 동적으로 인수를 받아 기능하도록 해주는 문법`을 지칭한다.

여러 개의 파라미터가 들어올 수 있는 메서드를 구성하는 방법은 대표적으로 메서드 오버로딩(overloading)으로 처리가 가능하다.

하지만 전달할 매개변수가 몇개인지 일정치 않을때 일일히 메서드를 오버로딩하여 구현하는 것은 변거로우며 별로 효율적이지 못하다.

여기서 가변 인자(varargs)가 힘을 발한다.

<br>

가변 인수는 `파라미터들을 통째로 배열로 받아들여 처리`하기 때문에 동적으로 매개변수를 받을 수 있게 된다.

메서드 파라미터 부분에 `‘타입... 매개변수명’` 으로 처리하면 사용이 가능하다.

아래와 같이 사용하면 된다. 

여기에서 str을 `String[] 배열 타입`으로 되어 여러 개의 매개변수들을 받는 것이다. 

```java
public void print (String... str){
		...
}
```

<br>

가변 인수는 전달 인자를 0개부터 n개까지 넣을수 있다. 

그리고 파라미터로 넘겨지는 값들을 모아서 `컴파일시 배열로 처리`된다. 

주의할 점은 인자들의 갯수에는 제한이 없지만, `배열 자료형은 매개변수 타입으로 명시된 것에 따라간다는 점`이다.

만일 매개변수가 가변 인자 외에 다른 매개 변수들도 받는다면, 반드시 가변 인자를 메서드 파라미터 가장 마지막에 위치하도록 정의해야 한다.

<br>

가변인수 메서드와 제네릭은 자바 5 때 함께 추가되었다. 

그래서 `서로 잘 어우러지리라 기대했지만 슬프게도 그렇지 않다. 
`
가변인수는 메서드에 넘기는 파라미터의 개수 클라이언트가 조절할 수 있게 해주는 것이라고 했다. 

하지만 구현 방식에 허점이 있어서 제네릭과 잘 어울리지 않는다. 

가변인수 메서드를 호출하면 `가변인수를 담기 위한 배열`이 자동으로 하나 만들어진다. 

그런데 내부로 감춰야 했을 이 `배열을 그만 클라이언트에 노출`하는 문제가 생긴 것이다. 

<br>

## 🚨 제네릭과 가변인수 문제점

이렇게 가변인수 담을 배열을 노출해서 제네릭과 사용할 때 문제가 생긴 것이다. 

`가변인수 매개변수에 제네릭 or 매개변수화 타입이 포함되면 알기 어려운 컴파일 경고가 발생`한다. 

메서드를 선언할 때 파라미터에 제네릭, 매개변수화 타입으로 가변인수 선언하면 컴파일 경고가 발생한다는 것이다. 

그리고 가변인수를 파라미터로 받는 메서드를 호출할 때에도 가변인수가 제네릭 or 매개변수화 타입으로 추론되면 컴파일 경고 발생한다. 

즉 아래와 같이 코드 작성하면 컴파일 경고가 발생한다는 것이다. 

```java
public void print(T... str){
		...
}
```

<br>

## 🤷‍♂️ 제네릭과 가변인수 문제점 이유

왜 컴파일 경고가 발생하는지 자세히 알아보자. 

실체화 불가 타입 = 거의 모든 제네릭과 매개변수 타입은 런타임에는 컴파일타임보다 타입 관련 정보 적게 담고 있다고 했다. 

런타임에는 타입이 제거되기 때문이다. 

그래서 `제네릭 배열을 만들 수 없었다`. 

그런데 `가변인수를 사용하면 매개변수들을 배열`로 받는다고 하였다. 

그런데 제네릭 배열 생성은 자바에서 허용되지 않기 때문에, 컴파일러는 내부적으로 제`네릭 타입의 가변인수 매개변수를 Object[]로 처리`한다. 

그런데 이렇게 `매개변수들을 Object[]로 받는 것`은 런타임에 ClassCastException을 유발할 수 있는 `타입 안전성을 위반할 가능성`이 있다. 

다음과 같은 흐름인 것이다. 

```java
T... str -> T[] str -> Object[] str
                X
```

<br>

제네릭과 가변인수를 함께 사용하면 발생하는 컴파일 경고는 `힙 오염 발생할 수 있다는 경고`이다. 

왜 힙 오염이 발생할 수 있는가 하면 매개변수화 타입의 변수가 타입이 다른 객체를 참조하면 힙 오염이 발생한다. 

다른 타입의 객체를 참조하는 상황에서 컴`파일러가 자동 생성한 형변환이 실패할 수 있다`. 

위처럼 제네릭과 가변인수 함께 사용하면 Object[]로 처리되어서 힙 오염을 일으킬 수 있는 것이다. 

그래서 힙 오염 발생할 수 있다는 컴파일 경고가 발생하는 것이다. 

<br>

이렇듯 `제네릭을 사용하면 컴파일러가 자동 형변환하고 가변인수를 함께 사용하면 Object[]로 처리해 타입 안전성이 깨질 수 있다`. 

따라서 제네릭 가변인수 배열 매개변수에 값을 저장하는 것은 안전하지 않다. 

<br>

>제네릭과 가변인수 함께 사용하면 컴파일 경고 나는 이유를 정리하면 다음과 같다. 
>
>1. 가변인수 사용 시 배열로 처리된다. 
>
>2. 제네릭은 런타임에 타입이 소거되기 때문에 제네릭 배열 만들 수 없다. 
>
>3. 제네릭과 가변인수 사용 시 위의 이유로 Object[]로 처리된다. 
>
>4. Object[]로 처리하면 힙 오염, 타입 안전성을 위반할 수 있다. 
>
>5. 따라서 제네릭과 가변인수 함께 사용하면 컴파일 경고가 발생한다. 

<br>

## ✅ 제네릭과 가변인수 허용 이유

그렇다면 이렇게 문제가 있는 제네릭과 가변인수를 함`께 사용하는 것을 왜 허용`하게 두었을까?

제네릭 배열을 직접 생성하는 것은 안된다고 배웠다. 

그런데 제네릭 가변인수 매개변수를 받는 메서드는 왜 선언할 수 있는 것인가?

<br>

왜냐하면 `제네릭 가변인수 매개변수를 받는 메서드가 실무에서 매우 유용하기 때문`이다. 

그래서 언어 설계자는 이 모순을 수용하기로 한 것이다. 

자바 라이브러리도 이런 메서드가 여러 개 있다. 

- Arrays.asList(T… a)
- Collections.addAll(Collection<? super T> c, T… elements)
- …

그래도 `자바 라이브러리가 제공하는 메서드들은 타입 안전`하다. 

<br>

## 📥 제네릭과 가변인수 사용 시 경고 숨기는 법

자바 7 전에는 제네릭 가변인수 메서드의 작성자가 클라이언트 쪽에서 발생하는 `경고에 대해서 할 수 있는 2가지` 밖에 없었다. 

- 경고를 그냥 둬서 메서드 사용하기 꺼림칙함.

- 메서드 호출하는 곳마다 @SuppresssWarnings(”unchecke”) 달아 경고 숨김.

<br>

@SuppresssWarnings로 경고를 숨기는 것은 다음과 같은 문제가 있다. 

- 지루한 작업임

- 가독성을 떨어뜨림

- 진짜 문제 알리는 경고마저 숨기는 안 좋은 결과 초래함.

<br>

자바 7에서는 `@SafeVarags annotation이 추가`되었다. 

그래서 제네릭 가변인수 메서드 작성자가 클라이언트 측에서 발생하는 경고를 숨길 수 있게 되었다. 

이 annotation은 메서드 작성자가 그 `메서드가 타입 안전함을 보장`하는 장치인 것이다. 

컴파일러는 안전하다는 약속을 믿고 경고를 더 이상 하지 않는다. 

<br>

@SuppressWarnings와 @SafeVarargs `둘 다 경고 숨기는 것`인데 뭐가 다른가 싶다. 

하지만 두 annotation의 차이점은 다음과 같다. 

- `용도:`
    - @SuppressWarnings는 다양한 종류의 경고를 억제하는 데 사용된다.
    
    - @SafeVarargs는 제네릭 사용하는 `가변인수의 힙 오염 경고만 억제하는데 특화`되어 있다.

- `적용 범위:`
    - @SuppressWarnings는 메소드, 타입, 필드 등 거의 모든 선언에 적용할 수 있다.
    
    - `@SafeVarargs는 오직 메소드와 생성자에만 적용`되며, 그 메소드나 생성자는 final이거나 static이어야 한다.

<br>

@SafeVarargs는 힙 오염 경고만 억제하기 때문에 `진짜 문제 알리는 경고 숨기는 것을 피할 수 있는 것`이다. 

<br>

## 🔎 경고 숨기기 위한 메서드 안전한지 확인하는 법

그래서 제네릭 가변인수 매개변수 받는 메서드 유용하고 이제 경고도 숨길 수 있으니 그냥 사용해도 될 것 같다. 

하지만 이전 @SuppressWarnings에도 봤듯이 경고 숨기는 `@SafeVarargs는 메서드가 안전한게 확실하지 않으면 절대 달면 안된다. `

<br>

그렇다면 메서드가 안전한지 어떻게 확신하는가?

>아래 `2가지 조건을 동시에 만족`한다면 메서드가 안전하다. 
>
>- 메서드가 가변인수 매개변수 담는 제네릭 배열에 아무것도 저장하지 않고 가변인수 매개변수들 덮어쓰지 않는다.
>
>- 제네릭 배열의 참조 밖으로 노출되지 않고 신뢰할 수 없는 코드가 제네릭 배열에 접근할 수 없다.

<br>

이 조건들을 둘 다 만족한다면 타입 안전하다. 

즉 이 가변인수 매개변수 배열이 호출하는 쪽으로부터 그 메서드로 매개변수 전달하는 일만 하면 메서드는 안전한 것이다. 

따라서 @SafeVarargs 메서드에 달고 제네릭 가변인수 매개변수 받는 메서드 사용할 수 있는 것이다. 

<br>

## ⚠ 제네릭과 가변인수 사용 시 주의점

제네릭 가변인수 매개변수 받는 메서드 사용할 때 `주의할 점`이 있다. 

가변인수 매개변수 배열에 `아무것도 저장하지 않고도 타입 안전성을 깰 수 있어 주의`해야 한다. 

왜 주의해야 하는지 예시를 통해 알아보자. 

<br>

아래와 같이 `가변인수로 넘어온 매개변수들을 배열에 담아 반환하는 제너릭 메서드`가 있다. 

가변인수는 배열로 처리되니 문제 없어 보인다. 

```java
static <T> T[] toArray(T... args){
		return args;
}
```

<br>

이 메서드가 반환하는 배열의 타입 T는 메서드에 매개변수 넘기는 컴파일 타임에 결정이 된다. 

그런데 그 시점에는 컴파일러에게 충분한 정보가 주어지지 않아 타입을 잘못 판단할 수 있다. 

따라서 가변인수 매개변수 배열을 그대로 반환하면 힙 오염이 메서드를 호출한 쪽의 콜스택으로까지 전이된다. 

문제가 될 수 있는 배열을 반환했기 때문이다. 

`가변인수 매개변수 배열은 Object[] 이기 때문에 Object[]을 반환`하는 것이다. 

위에서 `Object[]을 사용하면 문제`가 생길 수 있다고 했다. 

<br>

이렇게 되면 `어디에서 진짜 문제인지 찾기도 어렵다`. 

배열이 계속 반환되어 실제 사용하려고 할 때 오류가 발생하면 문제가 되는 이 toArray 메서드를 찾아오기도 힘들 것이다. 

그리고 이 toArray 메서드의 가변인수 매개변수 배열은 실제 매개변수가 저장된 후 변경된 적도 없어서 더 이 toArray 메서드가 문제라는 것을 찾기 어렵다. 

<br>

## ♻ @SafeVargs외 다른 방법

제너릭과 가변인수를 함께 사용할 때 @`SafeVarargs가 유일한 정답은 아니다`. 

배열보다는 리스트를 사용하라는 item 28의 조언을 따라 `실체는 배열인 가변인수 매개변수를 List 매개변수`로 바꿀 수 있다. 

<br>

`가변인수 매개변수 사용 코드`

```java
@SafeVarargs
static <T> List<T> flatten(List<? extends T>... lists){
		...
}
```

<br>

`List 매개변수 사용 코드` 

```java
static <T> List<T> flatten(List<List<? extends T>> lists){
		...
}
```

<br>

이렇게 List 매개변수를 사용하려면 정적 팩터리 메서드인 `List.of를 활용`해 메서드에 임의 개수의 매개변수를 넘길 수 있다. 

아래와 같이 사용하는 것이다. 

```java
audience = flatten(List.of(a, b, c));
```

<br>

이 방식의 장단점을 알아보자. 

**`장점`**

- 컴파일러가 메서드의 타입 안전성을 검증할 수 있다.
    - @SafeVarargs 직접 달지 않아도 된다.
    
    - 실수로 안전하다고 판단할 걱정도 없다.

- 가변인수 메서드를 안전하게 작성하는게 불가능한 상황에서도 쓸 수 있다.

<br>

**`단점`**

- 클라이언트 코드가 살짝 지저분해진다.

- 속도가 조금 느려질 수 있다.

<br>

## ‼ 결론

`가변인수와 제네릭은 궁합이 좋지 않다.` 

가변인수 기능은 배열을 노출해 추상화가 완벽하지 못하다. 

그리고 배열과 제네릭은 타입 규칙이 서로 다르다. 

그래서 궁합이 좋지 않은 것이다. 

<br>

하지만 제네릭 가변인수 매개변수는 타입 안전하지 않지만 허용이 된다. 

메서드에 제네릭 가변인수 매개변수 사용하려면 다음과 같이 하면 된다. 

- `메서드가 타입 안전한지 확인한다`.

- `@SafeVarargs 달아 사용하는데 불편함이 없게 한다`.

<br>

## 📍 references

- [가변인수](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B3%80-%EC%9D%B8%EC%88%98Varargs-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EB%A5%BC-%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C)