# 7️⃣1️⃣ Item 71 : 필요 없는 검사 예외 사용은 피하라

<br>

## 📍 목차
1. 검사 예외 장단점
2. 검사 예외 사용 경우 
3. 검사 예외 회피 방법
4. 결론

<br>

## 🆚 검사 예외 장단점

### 👍 검사 예외 장점

1. **API와 프로그램의 질을 높일 수 있다.**
    1. 검사 예외를 싫어하는 자바 프로그래머가 많지만 `제대로 활용하면 질을 높일 수 있다`. 
2. **안전성을 높이게끔 해준다.** 
    1. 검사 예외는 발생한 문제를 `프로그래머가 처리`하기 때문이다. 
    2. 결과를 코드로 반환하거나 비검사 예외를 던지는 것보다 `안전성이 높다`. 

<br>

### 👎 검사 예외 단점

1. **쓰기 불편한 API가 될 수 있다.** 
    1. 검사 예외를 과하게 사용하면 `쓰기 불편`할 수 있다. 
2. **검사 예외 던지는 메서드 호출하는 부분에서 처리해야 한다.** 
    1. 어떤 메서드가 검사 예외를 던질 수 있다고 선언된 것이다. 
    2. 그러면 이 `메서드를 호출하는 코드에서 아래 일 중 하나`를 해야 한다. 
        1. catch 블록을 두어 예외를 붙잡아 처리
        2. 더 바깥으로 예외를 던져 문제를 전파
    3. 이렇게 호출하는 코드에서 뭔가 해야 하는 것은 `API 사용자에게 부담`을 줌
3. **검사 예외 던지는 메서드는 스트림 안에서 직접 사용 불가.**

<br>

## ⚠ 검사 예외 사용 경우

위의 검사 예외의 `단점을 감수하고 부담을 받아들일 수 있는 경우`는 아래가 있다. 

1. API를 **제대로 사용해도 발생할 수 있는 예외**인 경우
2. 프로그래머가 **의미 있는 조치를 취할 수 있는 경우** 

<br>

그러나 둘 중 어디에도 해당하지 않는다면 `비검사 예외를 사용하는 것이 좋다`. 

둘 중 어디에도 해당하지 않는데 검사 예외를 쓰면 아래와 같은 코드가 나올 수 있다. 

<br>

아래처럼 검사 예외를 catch에서 잡아서 `비검사 예외로 바꾸는 것`이다. 

```java
}catch (TheCheckedException e){
		throw new AssertionError(); // AssertionError = 비검사 예외
}
```

<br>

또는 그냥 `exception을 찍고 시스템을 종료`해버리는 것이다. 

```java
}catch (TheCheckedException e){
		e.printStackTrace();
		System.exit(1);
}
```

<br>

이게 올바른 처리인가 싶고 보기 좋은 코드인가 싶은 `의문이 든다`. 

이렇듯 `더 나은 방법이 없다면 비검사 예외를 선택`해야 한다. 

<br>

## ↩ 검사 예외 회피 방법

메서드가 `단 하나의 검사 예외를 던질 때` 더 골치가 아파진다. 

검사 예외를 여러 개 던지는 경우에는 catch문 여러 개로 처리하면 된다. 

<br>

그런데 검사 예외가 하나면 `이 하나의 검사 예외 때문에 아래와 같은 문제들이 발생`한다. 

1. API 사용자는 try 블록 추가
2. 스트림에서 직접 사용 불가

<br>

그래서 이렇게 메서드가 단 하나의 검사 예외를 던지는 상황이라면 `검사 예외를 안 던지는 방법이 없는지 고민`해볼 가치가 있다. 

<br>

그래서 검사 예외 회피 방법들을 보자. 

<br>

### 1️⃣ 검사 예외 회피 방법 1

검사 예외를 회피하는 가장 쉬운 방법은 `적절한 결과 타입을 담은 옵셔널을 반환`하는 것이다. 

<br>

`검사 예외를 던지는 대신 단순히 빈 옵셔널을 반환`하면 된다. 

<br>

이 방식의 단점이라면 예외가 발생한 이유를 알려주는 `부가 정보를 담을 수 없다`는 것이다. 

<br>

반면 검사 예외를 사용하면 구체적인 예외 타입과 그 타입이 제공하는 메서드들을 활용해 부가 정보를 제공할 수 있다. 

<br>

### 2️⃣ 검사 예외 회피 방법 2

검사 예외를 회피하는 또 다른 방법은 검사 예외를 던지는 메서드를 `2개로 쪼개 비검사 예외로 바꾸는 것`이다. 

<br>

어떻게 쪼개는가 하면 아래와 같이 2개로 쪼개는 것이다. 

1. **예외가 던져질지 여부를 boolean 값으로 반환**하는 상태 검사 메서드
2. **쪼개기 전 기존 메서드가 하는 일**을 하는 메서드 

<br>

원래는 아래와 같이 검사 예외를 던지는 하나의 메서드 = obj.action(args) 메서드였던 것이다. 

```java
try{
		obj.action(args);
} catch (TheCheckedException e){
		... // 예외 상황에 대처
}
```

<br>

그런데 회피 방법으로 리팩터링하면 아래와 같이 2개의 메서드로 나뉘는 것이다. 

1. obj.actionPermitted(args)
2. obj.action(args)

```java
if(obj.actionPermitted(args)){
		obj.action(args);
} else{
		... // 예외 상황에 대처한다. 
}
```

<br>

검사 예외를 던지는 action 메서드를 2개로 나눈 것이다. 

<br>

이 리팩터링을 `모든 상황에 적용할 수는 없다`. 

그래도 적용할 수 있다면 `더 쓰기 편한 API를 제공`할 수 있다. 

리팩터링 후의 API가 `딱히 더 아름답진 않지만 더 유연한 것은 확실`하다. 

<br>

리팩터링 전의 코드를 사용해도 되는 경우는 아래와 같다. 

1. 프로그래머가 이 메서드가 성공하리라는 것을 아는 경우
2. 실패 시 스레드를 중단하길 원하는 경우 

<br>

이 경우는 그냥 검사 예외를 던져서 진행하라는 것이다. 

<br>

그런데 이런 경우가 아니라 그냥 `action 메서드를 주로 호출할 것이라고 판단되면` 리팩터링 후의 코드를 사용하는 것이 바람직하다고 한다. 

<br>

리팩터링이 적절하지 않아 `리팩터링 전의 코드를 사용해야 하는 상황`이 또 있다. 

1. 외부 동기화 없이 메서드에 **여러 스레드가 동시에 접근 가능한 경우**
2. 외부 요인에 의해 **상태가 변할 수 있는 경우** 
    1. 왜냐하면 상태 검사 메서드인 actionPermitted와 action 호출 사이에 객체의 상태가 변할 수 있기 때문이다. 
3. actionPermitted가 action 메서드의 **작업 일부를 중복 수행하는 경우**
    1. 성능에서 손해보기 때문이다. 

<br>

## 📌 결론

API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자.

복구가 가능하고 호출자가 그 처리를 해주길 바란다면 우선 옵셔널을 반환해도 될지를 고민하자. 

옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.